<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why Apple makes better software</title>
<meta name="author" content="Salih Muhammed" />
<meta name="generator" content="Org Mode" />
<!DOCTYPE html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#ffffff">
  <meta charset="utf-8">
  <meta name="theme-color" content="#ffffff">
  <meta name="viewport" content= "width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style/toc.css">
  <link rel="stylesheet" href="/style/tufte.css">
  <link rel="stylesheet" href="/style/main.css">




  <script async data-id="101390423" src= "//static.getclicky.com/js"></script> <noscript>
  <p><img alt="Clicky" width="1" height="1" src= "//in.getclicky.com/101390423ns.gif"></p></noscript>

<!-- Import LazySizes - State-of-the-art lazy loading library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js" async></script>

<!-- Optional: Import plugins for better performance -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/plugins/unveilhooks/ls.unveilhooks.min.js" async></script>

<script>
// Only run on pages with 'art_paintings_media' in the path
if (window.location.pathname.includes('art_paintings_media')) {
  document.addEventListener('DOMContentLoaded', function() {
    
    // Configure LazySizes for optimal performance
    window.lazySizesConfig = window.lazySizesConfig || {};
    window.lazySizesConfig.loadMode = 1; // Load images one at a time for better performance
    window.lazySizesConfig.expand = 50; // Load images 50px before they enter viewport
    window.lazySizesConfig.expFactor = 1.5; // Expand loading area
    window.lazySizesConfig.hFac = 0.4; // Height factor for loading trigger

    // Add CSS for smooth transitions and collapsible content
    const style = document.createElement('style');
    style.textContent = `
      .lazyload,
      .lazyloading {
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }
      .lazyloaded {
        opacity: 1;
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      .collapsible-content.collapsed {
        max-height: 0 !important;
      }
      .collapsible-content.expanded {
        max-height: none;
      }
      /* Blur effect while loading (optional) */
      .lazyloading {
        filter: blur(5px);
        opacity: 0.7;
      }
      .lazyloaded {
        filter: none;
      }
    `;
    document.head.appendChild(style);

    // Find all h3 elements
    const h3Elements = document.querySelectorAll('h3');

    h3Elements.forEach(function(h3) {
      // Make h3 clickable and add icon
      h3.style.position = 'relative';
      h3.style.cursor = 'pointer';
      h3.style.paddingLeft = '20px';
      h3.style.userSelect = 'none';

      // Add the arrow icon
      const icon = document.createElement('span');
      icon.innerHTML = '▶';
      icon.style.position = 'absolute';
      icon.style.left = '0px';
      icon.style.top = '50%';
      icon.style.transform = 'translateY(-50%)';
      icon.style.transition = 'transform 0.2s';
      icon.style.fontSize = '0.8em';
      icon.style.color = 'rgb(102, 102, 102)';
      icon.style.fontFamily = 'monospace';

      h3.insertBefore(icon, h3.firstChild);

      // Find all content after this h3 until the next h3 or end of parent
      const contentElements = [];
      let nextElement = h3.nextElementSibling;

      while (nextElement && nextElement.tagName !== 'H3') {
        contentElements.push(nextElement);
        nextElement = nextElement.nextElementSibling;
      }

      // Create a wrapper for smooth collapsing
      const wrapper = document.createElement('div');
      wrapper.className = 'collapsible-content collapsed';
      wrapper.style.maxHeight = '0';

      // Move content elements into wrapper
      contentElements.forEach(function(element) {
        wrapper.appendChild(element);
      });

      // Insert wrapper after h3
      h3.parentNode.insertBefore(wrapper, h3.nextSibling);

      // Prepare images for LazySizes lazy loading and make them clickable
      const prepareImagesForLazyLoading = (container) => {
        const images = container.querySelectorAll('img');
        images.forEach(function(img) {
          // Only process if not already processed
          if (!img.classList.contains('lazyload') && !img.dataset.processed) {
            // Store original src in data-src for LazySizes
            if (img.src && img.src !== '' && !img.src.startsWith('data:')) {
              img.dataset.src = img.src;
              // Use a tiny placeholder or low-quality placeholder
              img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3Crect width="1" height="1" fill="%23f0f0f0"/%3E%3C/svg%3E';
            }

            // Handle srcset for responsive images
            if (img.srcset && img.srcset !== '') {
              img.dataset.srcset = img.srcset;
              img.srcset = '';
            }

            // Handle sizes attribute
            if (img.sizes) {
              img.dataset.sizes = img.sizes;
            }

            // Add LazySizes classes
            img.classList.add('lazyload');

            // Make image clickable - add cursor pointer
            img.style.cursor = 'pointer';

            // Add click handler to open image in new tab
            img.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation(); // Prevent triggering h3 collapse

              // Get the actual image URL (either from src or data-src)
              let imageUrl = this.src;
              if (this.dataset.src && !this.src.startsWith('data:')) {
                imageUrl = this.dataset.src;
              } else if (this.src.startsWith('data:') && this.dataset.src) {
                imageUrl = this.dataset.src;
              }

              // Open image in new tab
              if (imageUrl && !imageUrl.startsWith('data:')) {
                window.open(imageUrl, '_blank');
              }
            });

            // Mark as processed
            img.dataset.processed = 'true';

            // Maintain aspect ratio to prevent layout shift
            if (!img.style.aspectRatio && img.width && img.height) {
              img.style.aspectRatio = img.width + '/' + img.height;
            }
          }
        });
      };

      // Prepare all images in this section for lazy loading
      prepareImagesForLazyLoading(wrapper);

      // Track collapsed state
      let isCollapsed = true;
      let hasBeenExpanded = false;

      // Add click handler
      h3.addEventListener('click', function(e) {
        e.preventDefault();

        if (isCollapsed) {
          // Expand: show content and activate lazy loading
          icon.style.transform = 'translateY(-50%) rotate(90deg)';
          wrapper.classList.remove('collapsed');
          wrapper.classList.add('expanded');
          wrapper.style.maxHeight = wrapper.scrollHeight + 'px';

          // Only activate LazySizes for this section when first expanded
          if (!hasBeenExpanded) {
            // Trigger LazySizes to check for images in this newly visible section
            if (window.lazySizes) {
              // Force LazySizes to check all images in this wrapper
              const lazyImages = wrapper.querySelectorAll('.lazyload');
              lazyImages.forEach(img => {
                // Add to LazySizes queue
                window.lazySizes.loader.unveil(img);
              });
            }
            hasBeenExpanded = true;
          }

          isCollapsed = false;

          // Recalculate height after images potentially load
          setTimeout(() => {
            if (!isCollapsed) {
              wrapper.style.maxHeight = wrapper.scrollHeight + 'px';
            }
          }, 100);

        } else {
          // Collapse: hide content
          icon.style.transform = 'translateY(-50%) rotate(0deg)';
          wrapper.classList.remove('expanded');
          wrapper.classList.add('collapsed');
          wrapper.style.maxHeight = '0';

          isCollapsed = true;
        }
      });

      // Listen for LazySizes events to adjust height dynamically
      wrapper.addEventListener('lazyloaded', function(e) {
        if (!isCollapsed) {
          // Adjust wrapper height when images load
          setTimeout(() => {
            wrapper.style.maxHeight = wrapper.scrollHeight + 'px';
          }, 50);
        }
      });
    });
  });
}
</script>

<script>



  
// Stack Page Formatter - Apply inline layout to specific pages
(function() {
  'use strict';
  
  // Check if current page should have the formatting applied
  function shouldApplyFormatting() {
    const path = window.location.pathname;
    
    // Check if path matches our target patterns
    return path === '/stack' || 
           path === '/stack.html' || 
           path.startsWith('/sh/');
  }
  
  // Only proceed if we're on a target page
  if (!shouldApplyFormatting()) {
    return;
  }
  
  // Add CSS styles
  function addStyles() {
    const style = document.createElement('style');
    style.textContent = `
      /* Basic styling for entries */
      .outline-3 {
        margin-bottom: 1.5em;
        line-height: 1.5;
      }

      /* Style for reconstructed single paragraph */
      .entry-paragraph {
        margin: 0;
        line-height: 1.5;
        direction: inherit;
        unicode-bidi: plaintext;
      }

      /* Style for date - gray and nice */
      .entry-date {
        color: #666;
        font-size: 0.9em;
        margin-right: 0.5em;
      }

      /* Style for tag at end - gray and in parentheses */
      .entry-tag {
        display: inline !important;
        color: #666;
        margin-left: 0.5em;
      }

      /* Ensure all children stay inline */
      .entry-tag * {
        display: inline !important;
      }

      /* Override any existing tag styles */
      .entry-tag p,
      .entry-tag div {
        display: inline !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      /* Hide block elements that will be moved */
      .outline-3 .moved-block {
        display: block;
        margin: 0.5em 0;
      }

      /* Ensure proper anchor target visibility */
      .outline-3[id] {
        scroll-margin-top: 20px;
      }
    `;
    document.head.appendChild(style);
  }
  
  // Extract ID from container div
  function extractIdFromContainer(entry) {
    const containerId = entry.id;
    if (containerId && containerId.startsWith('outline-container-')) {
      return containerId.replace('outline-container-', '');
    }
    return null;
  }
  
  // Apply the formatting transformation
  function applyFormatting() {
    // Process each entry
    const entries = document.querySelectorAll('.outline-3');
    
    entries.forEach((entry, index) => {
      // Extract the anchor ID from the container before transformation
      const anchorId = extractIdFromContainer(entry);
      
      // Extract components
      const h3 = entry.querySelector('h3');
      const notes = entry.querySelector('.notes');
      const outlineText = entry.querySelector('.outline-text-3');
      const tag = entry.querySelector('.tag');
      
      if (!h3 || !outlineText) return;
      
      // Get title text (preserve any TODO/DONE prefixes and links)
      let titleText = h3.innerHTML;
      
      // Get timestamp
      let timestampText = '';
      if (notes) {
        const timestamp = notes.querySelector('.timestamp');
        if (timestamp) {
          timestampText = timestamp.textContent;
        }
      }
      
      // Get content paragraphs (excluding notes and tag)
      const contentParagraphs = [];
      const blockElements = [];
      
      Array.from(outlineText.children).forEach(child => {
        if (child.classList.contains('notes') || child.classList.contains('tag')) {
          return; // Skip these
        }
        
        if (child.tagName === 'P') {
          contentParagraphs.push(child.innerHTML);
        } else if (child.tagName === 'UL' || child.tagName === 'OL' || 
                   child.tagName === 'BLOCKQUOTE' || child.tagName === 'PRE' ||
                   child.tagName === 'DL' || child.classList.contains('epigraph')) {
          blockElements.push(child.outerHTML);
        } else if (child.tagName === 'DIV' && child.classList.contains('epigraph')) {
          blockElements.push(child.outerHTML);
        }
      });
      
      // Get tag HTML (preserve links and formatting)
      let tagHtml = '';
      if (tag) {
        tagHtml = tag.outerHTML;
      }
      
      // Construct the new single paragraph
      let newContent = '';
      
      // Add date at the start (gray)
      if (timestampText) {
        newContent += '<span class="entry-date">' + timestampText + '</span>';
      }
      
      // Add title with emdash
      newContent += titleText + ' — ';
      
      // Add content paragraphs
      newContent += contentParagraphs.join(' ');
      
      // Add tag at the end in parentheses (preserve HTML but force inline)
      if (tagHtml) {
        // Extract just the inner content and wrap it properly
        let tagContent = tag.innerHTML;
        newContent += ' <span class="entry-tag">(' + tagContent + ')</span>';
      }
      
      // Create new paragraph element
      const newParagraph = document.createElement('p');
      newParagraph.className = 'entry-paragraph';
      newParagraph.innerHTML = newContent;
      
      // Clear the entry and add the new paragraph
      entry.innerHTML = '';
      entry.appendChild(newParagraph);
      
      // Preserve the anchor ID by setting it on the transformed entry
      if (anchorId) {
        entry.id = anchorId;
      }
      
      // Add any block elements after the paragraph
      blockElements.forEach(blockHtml => {
        const blockDiv = document.createElement('div');
        blockDiv.className = 'moved-block';
        blockDiv.innerHTML = blockHtml;
        entry.appendChild(blockDiv);
      });
      
      // Add separator after each entry (except the last one)
      if (index < entries.length - 1) {
        const separator = document.createElement('hr');
        separator.style.margin = '1em 0';
        separator.style.border = 'none';
        separator.style.borderTop = '1px solid #ccc';
        entry.appendChild(separator);
      }
    });
  }
  
  // Initialize when DOM is ready
  function init() {
    addStyles();
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', applyFormatting);
    } else {
      applyFormatting();
    }
  }
  
  // Start the initialization
  init();
})();
</script>



</head>
<body>
</body>
</html>
</head>
<body>
<div id="preamble" class="status">
<div id="preamble" class="status">
  <div class="header" style="
    display: block !important;!i;!;
">
<a href="/">
<h1 class="title" style="
margin-block-start: auto;
    color: black;
">Hereby, all birds fly</h1>
      </a>
<hr class="header-divider" style="margin-block-end: -1em;">
  </div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Why Apple makes better software</h1>
</header><div class="tag" id="org72393cd">
<p>
This section was labeled under, or is related to <a href="../t/programming.html#4u5664n02wj0">Programming</a>
</p>

</div>
<p>
I believe that the software products that Apple builds are some of the most
well-engineered, well-designed, and well-written software ever. And I think
there are some reasons for that, most of them are not good ones:
</p>

<ol class="org-ol">
<li>Apple products are massively overpriced, which creates a significant surplus
that allows them to invest heavily in software development. Capitalism
rewards monopolistic pricing, and Apple has mastered the art of leveraging
brand power and exclusivity to justify insane markups. Unlike something like
Linux, which I’ve used for a long time, open-source projects struggle to get
consistent funding or sponsorship, making it much harder to compete at the
same level.</li>
<li>Apple does not care about backward compatibility, worldwide compatibility, or
anything else outside its walled garden. Their software is built to work
exclusively on Apple hardware, and they have zero interest in making it
usable for non-Apple users. They also deprecate anything older than seven
years, forcing people into costly upgrades. As someone who has worked
extensively with system architecture and design, I can confirm that a
significant amount of engineering effort typically goes into maintaining
backward compatibility and ensuring interoperability with the rest of the
tech ecosystem. By outright ignoring these two concerns, Apple engineers get
to focus almost entirely on UX, making their software feel smoother and more
polished than competitors.</li>
<li>Since (1), Apple can afford to invest in developing much better SDKs, which
ensures that software built on their platforms is high quality. This is why
you often find software that exists on both Apple’s OSs and other operating
systems but still runs better on Apple’s—because their development tools and
ecosystem are simply better funded. This also attracts top-tier developers
who prefer the stability and optimization of Apple’s environment, further
reinforcing their advantage.</li>
<li>Apple controls both the hardware and the software, which means they don’t
have to deal with the same fragmentation issues that plague other ecosystems.
Unlike Windows or Android, where developers have to account for a ridiculous
range of hardware variations, Apple’s tight integration allows them to
optimize performance and deliver a more cohesive experience. However, this
comes at the cost of user freedom—if Apple decides they don’t want you
running certain apps or repairing your own device, you’re out of luck.</li>
<li>The cult-like marketing and closed ecosystem trap users into staying within
Apple’s platform. iMessage lock-in, proprietary file formats, restrictive App
Store policies—everything is designed to make switching inconvenient. This
means Apple doesn’t just create good software; they create software that
<b>feels</b> indispensable, even when there are equal or better alternatives
elsewhere.</li>
</ol>

<p>
Apple&rsquo;s software is good. Sometimes too good. But the reasons behind it are far
less about pure engineering brilliance and far more about strategic corporate
control, aggressive pricing, and an ecosystem that thrives on exclusivity.
</p>
</div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr style="
    clear: both;
">

<p> I seek refuge in God, from Satan the rejected. Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.1 (<a href="https://orgmode.org">Org</a> mode 9.7.31). Written by: Salih Muhammed, by the date of: 2025-03-17 Mon 00:07. Last build date: 2025-07-25 Fri 00:16.</p>

</div>
</div>
</div>
</body>
</html>
