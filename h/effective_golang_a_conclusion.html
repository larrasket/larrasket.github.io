<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Effective Go: A Conclusion</title>
<meta name="author" content="Salih Muhammed" />
<meta name="generator" content="Org Mode" />
<!DOCTYPE html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#ffffff">
  <meta charset="utf-8">
  <meta name="theme-color" content="#ffffff">
  <meta name="viewport" content= "width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style/toc.css">
  <link rel="stylesheet" href="/style/tufte.css">
  <link rel="stylesheet" href="/style/main.css">




  <script async data-id="101390423" src= "//static.getclicky.com/js"></script> <noscript>
  <p><img alt="Clicky" width="1" height="1" src= "//in.getclicky.com/101390423ns.gif"></p></noscript>
</head>
<body>
</body>
</html>
</head>
<body>
<div id="preamble" class="status">
<div id="preamble" class="status">
  <div class="header" style="
    display: block !important;!i;!;
">
<a href="/">
<h1 class="title" style="
margin-block-start: auto;
    color: black;
">Flectere si nequeo superos,<br><span class="subtitle" style="font-size: smaller; color: gray; font-style: italic;">acheronta movebo</span></h1>

      </a>

<hr class="header-divider" style="margin-block-end: -1em;">

  </div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Effective Go: A Conclusion</h1>
</header><div class="propert" id="org663ab13">
<p>
Part of a series on <a href="../cs/go.html#lvkhzyo02wj0">The Go Programming Language</a>
</p>

</div>


<div class="PREVIEW" id="orge352d6b">
<p>
Reading the effective Go document.
</p>

</div>



<p>
So I&rsquo;m currently reading the effective Go docs (as <a href="https://go.dev/doc/effective_go">html</a>, as <a href="http://www.math.bas.bg/bantchev/place/go/effective-go.pdf">pdf</a>).
</p>

<p>
Years ago when I was learning C, I remember reading something similar, it was by
google as well. And I think they used to name it &rsquo;effective&rsquo; too. It was hosted
on github pages by Google and was advocated as the &ldquo;google-style guidelines&rdquo;.
Moreover, it had the same problem that I&rsquo;m facing with effective-go right now:
there are many things that have nothing to do with the go programming language
itself, but a general guidelines that you should probably have learned during
the design principles class. I decided to filter out those irrelevant tips and
dissert a consultations, a recapitulation. So it might help someone.
</p>


<p>
References are used for non-td;lr that might be intersting for nerds.<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
I also might use <a href="https://github.com/golang/go/wiki/CodeReview">https://github.com/golang/go/wiki/CodeReview</a>
</span>
</p>
<div id="outline-container-org2cd1f6e" class="outline-2">
<h2 id="org2cd1f6e">Naming</h2>
<div class="outline-text-2" id="text-org2cd1f6e">
<p>
Names are as important in Go as in any other language. They even have semantic effect: the
visibility of a name outside a package is determined by whether its first character is upper
case. It&rsquo;s therefore worth spending a little time talking about naming conventions in Go
programs.
</p>
</div>
<div id="outline-container-orga047c50" class="outline-3">
<h3 id="orga047c50">Packages</h3>
<div class="outline-text-3" id="text-orga047c50">
<p>
package in <code>src/pkg/encoding/base64</code> is imported as &ldquo;<code>encoding/base64</code>&rdquo; but has name <code>base64</code>,
<b>not</b> <code>encoding_base64</code> and not <code>encodingBase64</code>. The importer of a package will use the name to
refer to its contents (the import . notation is
</p>
</div>
</div>
<div id="outline-container-orgf5e65c9" class="outline-3">
<h3 id="orgf5e65c9">Getters</h3>
<div class="outline-text-3" id="text-orgf5e65c9">
<p>
Go doesn&rsquo;t provide automatic support for getters and setters. There&rsquo;s nothing wrong with
providing getters and setters yourself, and it&rsquo;s often appropriate to do so, but it&rsquo;s
neither idiomatic nor necessary to put <code>Get</code> into the getter&rsquo;s name. If you have a field
called <code>owner</code> (lower case, unexported), the getter method should be called <code>Owner</code> (upper
case, exported), not <code>GetOwner</code>. The use of upper-case names for export provides the hook to
discriminate the field from the method. A setter function, if needed, will likely be called
<code>SetOwner</code>. Both names read well in practice:
</p>


<pre class="example" id="org3a963e2">
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>
</div>
</div>
<div id="outline-container-orge4ccdff" class="outline-3">
<h3 id="orge4ccdff">Interface (single-method)</h3>
<div class="outline-text-3" id="text-orge4ccdff">
<p>
By convention, one-method interfaces are named by the method name plus an -er suffix or
similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>,
<code>CloseNotifier</code> etc.
</p>

<p>
There are a number of such names and it&rsquo;s productive to honor them and the function names
they capture. <code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code> and so on have canonical
signatures and meanings. To avoid confusion, don&rsquo;t give your method one of those names
unless it has the same signature and meaning. Conversely, if your type implements a method
with the same meaning as a method on a well-known type, give it the same name and signature;
call your string-converter method <code>String</code> not <code>ToString</code>.
</p>
</div>
</div>
<div id="outline-container-org13533eb" class="outline-3">
<h3 id="org13533eb">MixedCaps</h3>
<div class="outline-text-3" id="text-org13533eb">
<p>
Finally, the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores
to write multiword names.
</p>
</div>
</div>
</div>
<div id="outline-container-org9fe1c52" class="outline-2">
<h2 id="org9fe1c52">Comments</h2>
<div class="outline-text-2" id="text-org9fe1c52">
<p>
“Doc comments” are comments that appear immediately before top-level package, const, func,
type, and var declarations with no intervening newlines. Every exported (capitalized) name
should have a doc comment.
</p>

<p>
For syntax, read: <a href="https://go.dev/doc/comment#Syntax">https://go.dev/doc/comment#Syntax</a>
</p>
</div>
<div id="outline-container-org1386404" class="outline-3">
<h3 id="org1386404">Inside packages</h3>
<div class="outline-text-3" id="text-org1386404">
<p>
Every package should have a package comment introducing the package. It provides information relevant to the package as a whole and generally sets expectations for the package. Especially in large packages, it can be helpful for the package comment to give a brief overview of the most important parts of the API, linking to other doc comments as needed.
</p>

<p>
If the package is simple, the package comment can be brief. For example:
</p>

<pre class="example" id="org77abb94">
// Package path implements utility routines for manipulating slash-separated
// paths.
//
// The path package should only be used for paths separated by forward
// slashes, such as the paths in URLs. This package does not deal with
// Windows paths with drive letters or backslashes; to manipulate
// operating system paths, use the [path/filepath] package.
package path
</pre>
</div>
</div>
<div id="outline-container-orgd551dc3" class="outline-3">
<h3 id="orgd551dc3"><span class="done KILL">KILL</span> Commands</h3>
</div>
<div id="outline-container-orgd86b6ac" class="outline-3">
<h3 id="orgd86b6ac"><code>type</code></h3>
<div class="outline-text-3" id="text-orgd86b6ac">
<p>
A type&rsquo;s doc comment should explain what each instance of that type represents or provides.
If the API is simple, the doc comment can be quite short. For example:
</p>

<pre class="example" id="orgf5ff8a2">
package zip

// A Reader serves content from a ZIP archive.
type Reader struct {
    ...
}
</pre>



<p>
By default, programmers should expect that a type is safe for use only by a single goroutine
at a time. If a type provides stronger guarantees, the doc comment should state them. For
example:
</p>


<pre class="example" id="org577ff95">
package regexp

// Regexp is the representation of a compiled regular expression.
// A Regexp is safe for concurrent use by multiple goroutines,
// except for configuration methods, such as Longest.
type Regexp struct {
    ...
}
</pre>



<p>
For a struct with exported fields, either the doc comment or per-field comments should
explain the meaning of each exported field. For example, this type&rsquo;s doc comment explains
the fields:
</p>

<pre class="example" id="org3d48115">
 package io

// A LimitedReader reads from R but limits the amount of
// data returned to just N bytes. Each call to Read
// updates N to reflect the new amount remaining.
// Read returns EOF when N &lt;= 0.
type LimitedReader struct {
    R   Reader // underlying reader
    N   int64  // max bytes remaining
}
</pre>

<p>
As with packages (above) and funcs (below), doc comments for types <b>start with complete
sentences naming the declared symbol</b>. An explicit subject often makes the wording clearer,
and it makes the text easier to search, whether on a web page or a command line.
</p>
</div>
</div>
<div id="outline-container-orgb552435" class="outline-3">
<h3 id="orgb552435"><code>func</code></h3>
<div class="outline-text-3" id="text-orgb552435">
<p>
A func&rsquo;s doc comment should explain what the function returns or, for functions called for
side effects, what it does. Named arguments or results can be referred to directly in the
comment, without any special syntax like backquotes. (A consequence of this convention is
that names like <code>a</code>, which might be mistaken for ordinary words, are typically avoided.) For
example:
</p>


<pre class="example" id="orgdbcf40f">
 package strconv

// Quote returns a double-quoted Go string literal representing s.
// The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
// for control characters and non-printable characters as defined by IsPrint.
func Quote(s string) string {
    ...
}
</pre>
</div>
</div>
<div id="outline-container-org7e161b9" class="outline-3">
<h3 id="org7e161b9"><code>const</code></h3>
<div class="outline-text-3" id="text-org7e161b9">
<p>
Go&rsquo;s declaration syntax allows grouping of declarations, in which case a single doc comment
can introduce a group of related constants, with individual constants only documented by
short end-of-line comments. For example:
</p>
<pre class="code"><code><span style="color: #545c5e;">// </span><span style="color: #545c5e;">The result of Scan is one of these tokens or a Unicode character.</span>
<span style="color: #4d9391; font-weight: bold;">const</span> (
<span style="color: #31b1351b37b1;"> </span>   <span style="color: #ab98b5; font-weight: bold;">EOF</span> = -(<span style="color: #ab98b5; font-weight: bold;">iota</span> + <span style="color: #cd5c60;">1</span>)
<span style="color: #31b1351b37b1;"> </span>   <span style="color: #ab98b5; font-weight: bold;">Ident</span>
<span style="color: #31b1351b37b1;"> </span>   <span style="color: #ab98b5; font-weight: bold;">Int</span>
<span style="color: #31b1351b37b1;"> </span>   <span style="color: #ab98b5; font-weight: bold;">Float</span>
<span style="color: #31b1351b37b1;"> </span>   <span style="color: #ab98b5; font-weight: bold;">Char</span>
<span style="color: #31b1351b37b1;"> </span>   ...
)
</code></pre>


<p>
Sometimes the group needs no doc comment at all. For example:
</p>

<pre class="example" id="org95f4025">
 package unicode // import "unicode"

const (
    MaxRune         = '\U0010FFFF' // maximum valid Unicode code point.
    ReplacementChar = '\uFFFD'     // represents invalid code points.
    MaxASCII        = '\u007F'     // maximum ASCII value.
    MaxLatin1       = '\u00FF'     // maximum Latin-1 value.
)
</pre>



<p>
On the other hand, ungrouped constants typically warrant a full doc comment starting with a complete sentence. For example:
</p>

<pre class="example" id="orgf7b97d2">
 package unicode

// Version is the Unicode edition from which the tables are derived.
const Version = "13.0.0"
</pre>
</div>
</div>
<div id="outline-container-orge5ce1fc" class="outline-3">
<h3 id="orge5ce1fc"><code>var</code></h3>
</div>
</div>
<div id="outline-container-org9c467f7" class="outline-2">
<h2 id="org9c467f7">CHECK Errors</h2>
<div class="outline-text-2" id="text-org9c467f7">
</div>
<div id="outline-container-orgd4ad1cf" class="outline-3">
<h3 id="orgd4ad1cf">Error Strings</h3>
<div class="outline-text-3" id="text-orgd4ad1cf">
<p>
Error strings should not be capitalized (unless beginning with proper nouns or acronyms) or
end with punctuation, since they are usually printed following other context. That is, use
<code>fmt.Errorf("something bad")</code> not <code>fmt.Errorf("Something bad")</code>, so that <code>log.Printf("Reading %s:
%v", filename, err)</code> formats without a spurious capital letter mid-message. This does not
apply to logging, which is implicitly line-oriented and not combined inside other messages.
</p>
</div>
</div>
</div>
<div id="outline-container-org4a55d24" class="outline-2">
<h2 id="org4a55d24">Other</h2>
<div class="outline-text-2" id="text-org4a55d24">
</div>
<div id="outline-container-orgdd70ef2" class="outline-3">
<h3 id="orgdd70ef2">Semicolons</h3>
<div class="outline-text-3" id="text-orgdd70ef2">
<p>
Idiomatic Go programs have semicolons only in places such as <code>for</code> loop clauses, to separate
the initializer, condition, and continuation elements. They are also necessary to separate
multiple statements on a line, should you write code that way<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
One consequence of the semicolon insertion rules is that you cannot put the opening brace of
a control structure ( <code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a
semicolon will be inserted before the brace, which could cause unwanted effects. Write them
like this



if i &lt; f() {
    g()
}



not like this



if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</span>.
</p>
</div>
</div>
<div id="outline-container-org569dd48" class="outline-3">
<h3 id="org569dd48">Declaring Variables</h3>
<div class="outline-text-3" id="text-org569dd48">
<ul class="org-ul">
<li>When declaring —but not initializing— a variable, <b>use the keyword <code>var</code></b></li>
<li>When declaring and initializing in the same time, use the short declaration form: <code>:=</code></li>
</ul>

<p>
When declaring an empty slice, prefer
</p>
<pre class="code"><code><span style="color: #4d9391; font-weight: bold;">var</span> <span style="color: #968cc7;">t</span> []<span style="color: #cd9575;">string</span>
</code></pre>
<p>
over
</p>
<pre class="code"><code><span style="color: #968cc7;">t</span> := []<span style="color: #cd9575;">string</span>{}
</code></pre>

<p>
The former declares a nil slice value, while the latter is non-nil but zero-length. They are
functionally equivalent—their <code>len</code> and <code>cap</code> are both zero—but the nil slice is the preferred
style.
</p>


<p>
Note that there are limited circumstances where a non-nil but zero-length slice is
preferred, such as when encoding JSON objects (a nil slice encodes to null, while []string{}
encodes to the JSON array []).
</p>

<p>
When designing interfaces, avoid making a distinction between a nil slice and a non-nil,
zero-length slice, as this can lead to subtle programming errors.
</p>
</div>
</div>
<div id="outline-container-org6e9f6cf" class="outline-3">
<h3 id="org6e9f6cf">Context</h3>
<div class="outline-text-3" id="text-org6e9f6cf">
<p>
Values of the context.Context type carry security credentials, tracing information,
deadlines, and cancellation signals across API and process boundaries. Go programs pass
Contexts explicitly along the entire function call chain from incoming RPCs and HTTP
requests to outgoing requests.
</p>

<p>
<b>Most functions that use a Context should accept it as their first parameter:</b>
</p>

<pre class="code"><code><span style="color: #4d9391; font-weight: bold;">func</span> <span style="color: #80bcb6;">F</span>(<span style="color: #968cc7;">ctx</span> <span style="color: #cd9575;">context.Context</span>, <span style="color: #545c5e;">/* </span><span style="color: #545c5e;">other arguments */</span>) {}
</code></pre>

<p>
A function that is never request-specific may use context.Background(), but err on the side
of passing a Context even if you think you don&rsquo;t need to. The default case is to pass a
Context; only use context.Background() directly if you have a good reason why the
alternative is a mistake.
</p>

<p>
<b>Don&rsquo;t add a Context member to a struct type</b>; instead add a <code>ctx</code> parameter to each method on
that type that needs to pass it along. The one exception is for methods whose signature must
match an interface in the standard library or in a third party library.
</p>

<p>
Don&rsquo;t create custom Context types or use interfaces other than Context in function
signatures.
</p>

<p>
If you have application data to pass around, put it in a parameter, in the receiver, in
globals, or, if it truly belongs there, in a Context value.
</p>

<p>
Contexts are immutable, so it&rsquo;s fine to pass the same ctx to multiple calls that share the
same deadline, cancellation signal, credentials, parent trace, etc.
</p>
</div>
</div>
<div id="outline-container-orgeccf696" class="outline-3">
<h3 id="orgeccf696">Rand</h3>
<div class="outline-text-3" id="text-orgeccf696">
<p>
Do not use package <code>math/rand</code> to generate keys, even throwaway ones. Unseeded, the generator
is completely predictable. Seeded with <code>time.Nanoseconds()</code>, there are just a few bits of
entropy. Instead, use <code>crypto/rand</code>&rsquo;s Reader, and if you need text, print to hexadecimal or
<code>base64</code>:
</p>

<pre class="code"><code><span style="color: #4d9391; font-weight: bold;">import</span> (
    <span style="color: #6fb593;">"crypto/rand"</span>
    <span style="color: #545c5e;">// </span><span style="color: #545c5e;">"encoding/base64"</span>
    <span style="color: #545c5e;">// </span><span style="color: #545c5e;">"encoding/hex"</span>
    <span style="color: #6fb593;">"fmt"</span>
)

<span style="color: #4d9391; font-weight: bold;">func</span> <span style="color: #80bcb6;">Key</span>() <span style="color: #cd9575;">string</span> {
    <span style="color: #968cc7;">buf</span> := <span style="color: #80bcb6;">make</span>([]<span style="color: #cd9575;">byte</span>, <span style="color: #cd5c60;">16</span>)
    <span style="color: #968cc7;">_</span>, <span style="color: #968cc7;">err</span> := rand.<span style="color: #80bcb6;">Read</span>(buf)
    <span style="color: #4d9391; font-weight: bold;">if</span> err != <span style="color: #ab98b5; font-weight: bold;">nil</span> {
        <span style="color: #80bcb6;">panic</span>(err)  <span style="color: #545c5e;">// </span><span style="color: #545c5e;">out of randomness, should never happen</span>
    }
    <span style="color: #4d9391; font-weight: bold;">return</span> fmt.<span style="color: #80bcb6;">Sprintf</span>(<span style="color: #6fb593;">"%x"</span>, buf)
    <span style="color: #545c5e;">// </span><span style="color: #545c5e;">or hex.EncodeToString(buf)</span>
    <span style="color: #545c5e;">// </span><span style="color: #545c5e;">or base64.StdEncoding.EncodeToString(buf)</span>
}

<span style="color: #4d9391; font-weight: bold;">func</span> <span style="color: #80bcb6;">main</span>() {
    fmt.<span style="color: #80bcb6;">Print</span>(<span style="color: #80bcb6;">Key</span>())
        }
</code></pre>
</div>
</div>
<div id="outline-container-org946db2a" class="outline-3">
<h3 id="org946db2a">Import Blank</h3>
<div class="outline-text-3" id="text-org946db2a">
<p>
Packages that are imported only for their side effects (using the syntax <code>import _ "pkg"</code>)
should only be imported in the main package of a program, or in tests that require them.
</p>
</div>
</div>
<div id="outline-container-org21b56bf" class="outline-3">
<h3 id="org21b56bf">Named Result Parameters</h3>
<div class="outline-text-3" id="text-org21b56bf">
<p>
Consider what it will look like in godoc. Named result parameters like:
</p>

<pre class="code"><code><span style="color: #4d9391; font-weight: bold;">func</span> (<span style="color: #968cc7;">n</span> *<span style="color: #cd9575;">Node</span>) <span style="color: #80bcb6;">Parent1</span>() (<span style="color: #968cc7;">node</span> *<span style="color: #cd9575;">Node</span>) {}
<span style="color: #4d9391; font-weight: bold;">func</span> (<span style="color: #968cc7;">n</span> *<span style="color: #cd9575;">Node</span>) <span style="color: #80bcb6;">Parent2</span>() (<span style="color: #968cc7;">node</span> *<span style="color: #cd9575;">Node</span>, <span style="color: #968cc7;">err</span> <span style="color: #cd9575;">error</span>) {}
</code></pre>
<p>
will be repetitive in godoc; better to use:
</p>

<pre class="code"><code><span style="color: #4d9391; font-weight: bold;">func</span> (<span style="color: #968cc7;">n</span> *<span style="color: #cd9575;">Node</span>) <span style="color: #80bcb6;">Parent1</span>() *<span style="color: #cd9575;">Node</span> {}
<span style="color: #4d9391; font-weight: bold;">func</span> (<span style="color: #968cc7;">n</span> *<span style="color: #cd9575;">Node</span>) <span style="color: #80bcb6;">Parent2</span>() (*<span style="color: #cd9575;">Node</span>, <span style="color: #cd9575;">error</span>) {}
</code></pre>

<p>
On the other hand, if a function returns two or three parameters of the same type, or if the
meaning of a result isn&rsquo;t clear from context, adding names may be useful in some contexts.
<b>Don&rsquo;t name result parameters just to avoid declaring a var inside the function; that trades
off a minor implementation brevity at the cost of unnecessary API verbosity.</b>
</p>
</div>
</div>
<div id="outline-container-orgf843517" class="outline-3">
<h3 id="orgf843517">Return Values</h3>
<div class="outline-text-3" id="text-orgf843517">
<ul class="org-ul">
<li>If the receiver is a <code>map</code>, <code>func</code> or <code>chan</code>, don&rsquo;t use a pointer to them. If the receiver is a
slice and the method doesn&rsquo;t reslice or reallocate the slice, don&rsquo;t use a pointer to it.</li>

<li>If the method needs to mutate the receiver, the receiver must be a pointer.</li>

<li>If the receiver is a <code>struct</code> that contains a sync.Mutex or similar synchronizing field, the
receiver must be a pointer to avoid copying.</li>

<li>If the receiver is a large <code>struct</code> or array, a pointer receiver is more efficient. How
large is large? Assume it&rsquo;s equivalent to passing all its elements as arguments to the
method. If that feels too large, it&rsquo;s also too large for the receiver.</li>

<li>Can function or methods, either concurrently or when called from this method, be mutating
the receiver? A value type creates a copy of the receiver when the method is invoked, so
outside updates will not be applied to this receiver. If changes must be visible in the
original receiver, the receiver must be a pointer.</li>

<li>If the receiver is a <code>struct</code>, array or slice and any of its elements is a pointer to
something that might be mutating, prefer a pointer receiver, as it will make the intention
clearer to the reader.</li>

<li>If the receiver is a small array or <code>struct</code> that is naturally a value type (for instance,
something like the time.Time type), with no mutable fields and no pointers, or is just a
simple basic type such as int or string, a value receiver makes sense. A value receiver
can reduce the amount of garbage that can be generated; if a value is passed to a value
method, an on-stack copy can be used instead of allocating on the heap. (The compiler
tries to be smart about avoiding this allocation, but it can&rsquo;t always succeed.) Don&rsquo;t
choose a value receiver type for this reason without profiling first.</li>

<li>Don&rsquo;t mix receiver types. Choose either pointers or <code>struct</code> types for all available
methods.</li>

<li>Finally, when in doubt, use a pointer receiver.</li>
</ul>
</div>
</div>
<div id="outline-container-org3ec1094" class="outline-3">
<h3 id="org3ec1094"><span class="done KILL">KILL</span> Interfaces</h3>
<div class="outline-text-3" id="text-org3ec1094">
<p>
Go interfaces generally belong in the package that uses values of the interface type, not
the package that implements those values. The implementing package should return concrete
(usually pointer or struct) types: that way, new methods can be added to implementations
without requiring extensive refactoring.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I also might use <a href="https://github.com/golang/go/wiki/CodeReview">https://github.com/golang/go/wiki/CodeReview</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
One consequence of the semicolon insertion rules is that you cannot put the opening brace of
a control structure ( <code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a
semicolon will be inserted before the brace, which could cause unwanted effects. Write them
like this
</p>

<pre class="example" id="org36b2708">
if i &lt; f() {
    g()
}
</pre>

<p class="footpara">
not like this
</p>

<pre class="example" id="org57b014d">
if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr style="
    clear: both;
">

<p> I seek refuge in God, from Satan the rejected. Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11). Written by: Salih Muhammed, by the date of: 2022-09-20 Tue 03:20. Last build date: 2024-07-04 Thu 21:55.</p>

</div>
</div>
</div>
</body>
</html>
