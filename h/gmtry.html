<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Introduction to Computational Geometry</title>
<meta name="author" content="Salih Muhammed" />
<meta name="description" content="The ultimate computational geometry for computer science tutorial" />
<meta name="generator" content="Org Mode" />
<!DOCTYPE html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#ffffff">
  <meta charset="utf-8">
  <meta name="theme-color" content="#ffffff">
  <meta name="viewport" content= "width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style/toc.css">
  <link rel="stylesheet" href="/style/tufte.css">
  <link rel="stylesheet" href="/style/main.css">




  <script async data-id="101390423" src= "//static.getclicky.com/js"></script> <noscript>
  <p><img alt="Clicky" width="1" height="1" src= "//in.getclicky.com/101390423ns.gif"></p></noscript>
</head>
<body>
</body>
</html>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="preamble" class="status">
  <div class="header" style="
    display: block !important;!i;!;
">
<a href="/">
<h1 class="title" style="
margin-block-start: auto;
    color: black;
">Ù„Ù‘ermontov</h1>

      </a>
<hr class="header-divider" style="margin-block-end: -1em;">
  </div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Introduction to Computational Geometry</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org911da22">Introduction</a></li>
<li><a href="#org327452a">Vectors</a></li>
<li><a href="#orgc7d17dd">Intersection</a></li>
<li><a href="#org7d6a227">Finding The Equation of a Line for a Segment</a></li>
<li><a href="#orga3d45bb">Orientation of 3 Points</a></li>
<li><a href="#org272e3d7">Finding a Circle From 3 Points</a></li>
<li><a href="#orge3a11c9">Convex Hull</a></li>
</ul>
</div>
</nav>
<div class="PREVIEW" id="org2f9eb4d">
<p>
Based on TopCoder&rsquo;s thrive and <a href="https://www.ti.inf.ethz.ch/ew/courses/CG13/index.html">Computational Geometry (252-1425-00L) HS13</a> lecture notes.
</p>

</div>

<div class="propert" id="orge13e1b1">
<p>
Part of a series on <a href="../cs/g.html#13122uo02wj0">Exploring Computational Geometry</a>
</p>

</div>


<p>
(Problems mostly from <a href="https://leetcode.com/tag/geometry">LeetCode</a>)
</p>
<div id="outline-container-org911da22" class="outline-2">
<h2 id="org911da22">Introduction</h2>
<div class="outline-text-2" id="text-org911da22">
<p>
I&rsquo;m not sure how to properly introduce this long plain text â€”or even how to put itâ€”. You can
easily consider it as a small handbook that contains some computational problems solutions,
or like Nietzsche says in his Dawn of Day:
</p>

<div class="epigraph"><blockquote>
<p>

</p>

<p>
&ldquo;A DIGRESSION.â€”A book like this is not intended to be read through at once, or to be read
aloud. It is intended more particularly for reference, especially on our walks and travels:
we must take it up and put it down again after a short reading, and, more especially, we
ought not to be amongst our usual surroundings.&rdquo;
</p>

</blockquote></div>

<p>
So, yeah. Read it when some problem tag is matched here (actually I wouldn&rsquo;t mind reading it
aloud but I liked to put the quoteðŸ˜Ž).
</p>
</div>
</div>
<div id="outline-container-org327452a" class="outline-2">
<h2 id="org327452a">Vectors</h2>
<div class="outline-text-2" id="text-org327452a">
<p>
Basically, a vector is a geometric object with length and direction (direction and
magnitude). In the case of two-dimension geometry, we represent vectors as a pair of numbers
\((x, y)\), it&rsquo;s important to understand vectors arithmetically, for example, a line segment
from \((1,3)\) to \((5,1)\) can be represented by the vector \((4,-2)\) (A line segment has two
endpoints which contains all the points of the line between them) you should notice that in
the second representation, a vector only defines the direction and the magnitude of the
segment, but it can&rsquo;t define the starting and the ending locations.
</p>
</div>
<div id="outline-container-orgc0d3337" class="outline-3">
<h3 id="orgc0d3337">Operations on Vectors</h3>
<div class="outline-text-3" id="text-orgc0d3337">
</div>
<div id="outline-container-org3c6a9e7" class="outline-4">
<h4 id="org3c6a9e7">Addition</h4>
<div class="outline-text-4" id="text-org3c6a9e7">
<p>
The most beloved operation in which authors wastes ~3 pages in their textbook to explain
it. You can add two vector together and as a result you get a new vector, if you have two
vectors \((x_1, y_1)\) and \((x_2, y_2)\) then the sum of them is the vector \((x_1 + x_2, y_1 +
y_2)\)
</p>
</div>
</div>
<div id="outline-container-org207e0c4" class="outline-4">
<h4 id="org207e0c4">Dot Product</h4>
<div class="outline-text-4" id="text-org207e0c4">
<p>
The dot product is <b>the sum of the corresponding element</b>, notice that it is not a vector,
but a number. For example, if we have the two vector \((x_1, y_1)\) and \((x_2, y_2)\) then
their dot product is simply \((x_{1} \cdot x_{2}) + (y_1 \cdot y_2)\), we call the product
number a <i>scalar</i>.
</p>

<p>
The reason why <i>scalar</i> is a useful concept (at least more than addition and subtraction) is
that, let \(A\) and \(B\) be two vectors, then \(A \cdot B = |A| \cdot |B| \cos(\theta)\) where
\(\theta\) is the angle between \(A\) and \(B\), \(|A|\) is called the norm of vector which is
computed from the formula \(\sqrt{ (x_{1})^2 + (y_{1})^2 }\) . Therefore, we can calculate any
angle between two vectors simply using two steps:
</p>

<ol class="org-ol">
<li>Calculate \(\cos(\theta) = \frac{a \cdot b}{|a| \cdot |b| }\)</li>
<li>Use the \(acos\) function to calculate \(\theta\)</li>
</ol>
</div>
</div>
<div id="outline-container-org675bd4b" class="outline-4">
<h4 id="org675bd4b">Cross Product</h4>
<div class="outline-text-4" id="text-org675bd4b">
<p>
This is more like the regular product: the cross product of 2D vectors \((x_1, y_1)\) and
\((x_2, y_2)\) is \(x_{1} \cdot y_{2} - y_{1} \cdot x_{2}\), and its formula \(A \cdot B = |A|
\cdot |B| \cdot sin(\theta)\) as you see can see, this operation can be useful too in
calculating \(\theta\) in some situations. However, \(\theta\) has a slightly different meaning
here, in this case the absolute value of \(\theta\) is the angle between the two vectors but
it is negative or positive based on the right-hand rule.
</p>
</div>
</div>
<div id="outline-container-org9e44ac4" class="outline-4">
<h4 id="org9e44ac4">Line-Point Distance</h4>
<div class="outline-text-4" id="text-org9e44ac4">
<p>
Lets say that you are given 3 points, \(A\), \(B\), and \(C\), and you want to find the distance
from the point $C$to the line defined by \(A\) and \(B\).The first step is to find the two
vectors from \(A\) to \(B\) \((AB)\) and from \(A\) to \(C\) $(AC).$
</p>

<p>
Now, take the cross product \(AB \cdot AC\), and divide by \(|AB|\). This gives you the distance
(denoted by the red line) as \(\frac{(AB \cdot AC)}{|AB|}\). And here you are done.
</p>


<figure id="org11b9c65">
<img src="../i/old/2022-01-19_04-58-41_screenshot.png" alt="2022-01-19_04-58-41_screenshot.png">

</figure>


<p>
The reason this works comes from some basic high school level geometry. The area of a
triangle is found as \(\frac{\text{base} \cdot \text{height}}{2}\). Now, the area of the triangle formed by \(A\), \(B\) and \(C\) is
given by  \(\frac{AB \cdot AC}{2}\)  Since the base of the triangle is formed by \(AB\), and the height of the
triangle is the distance from the line to \(C\). Therefore, what we have done is to find twice
the area of the triangle using the cross product, and then divided by the length of the
base. As always with cross products, the value may be negative, in which case the distance
is the absolute value.
</p>

<p>
Let&rsquo;s repeat in C(++):
</p>
<pre class="code"><code><span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">Compute the dot product AB &#8901; BC</span>
<span style="color: #f470df;">int</span> <span style="color: #f59280;">dot</span>(<span style="color: #f470df;">int</span>[] A, <span style="color: #f470df;">int</span>[] B, <span style="color: #f470df;">int</span>[] C) {
&#9474; AB = <span style="color: #ef80bf; font-weight: bold;">new</span> <span style="color: #f470df;">int</span>[2];
&#9474; BC = <span style="color: #ef80bf; font-weight: bold;">new</span> <span style="color: #f470df;">int</span>[2];
&#9474; AB[0] = B[0] - A[0];
&#9474; AB[1] = B[1] - A[1];
&#9474; BC[0] = C[0] - B[0];
&#9474; BC[1] = C[1] - B[1];
&#9474; <span style="color: #f470df;">int</span> <span style="color: #df7fff;">dot</span> = AB[0] * BC[0] + AB[1] * BC[1];
&#9474; <span style="color: #ef80bf; font-weight: bold;">return</span> dot;
}
<span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">Compute the cross product AB x AC</span>
<span style="color: #f470df;">int</span> <span style="color: #f59280;">cross</span>(<span style="color: #f470df;">int</span>[] A, <span style="color: #f470df;">int</span>[] B, <span style="color: #f470df;">int</span>[] C) {
&#9474; AB = <span style="color: #ef80bf; font-weight: bold;">new</span> <span style="color: #f470df;">int</span>[2];
&#9474; AC = <span style="color: #ef80bf; font-weight: bold;">new</span> <span style="color: #f470df;">int</span>[2];
&#9474; AB[0] = B[0] - A[0];
&#9474; AB[1] = B[1] - A[1];
&#9474; AC[0] = C[0] - A[0];
&#9474; AC[1] = C[1] - A[1];
&#9474; <span style="color: #f470df;">int</span> <span style="color: #df7fff;">cross</span> = AB[0] * AC[1] - AB[1] * AC[0];
&#9474; <span style="color: #ef80bf; font-weight: bold;">return</span> cross;
}
<span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">Compute the distance from A to B</span>
<span style="color: #f470df;">double</span> <span style="color: #f59280;">distance</span>(<span style="color: #f470df;">int</span>[] A, <span style="color: #f470df;">int</span>[] B) {
&#9474; <span style="color: #f470df;">int</span> <span style="color: #df7fff;">d1</span> = A[0] - B[0];
&#9474; <span style="color: #f470df;">int</span> <span style="color: #df7fff;">d2</span> = A[1] - B[1];
&#9474; <span style="color: #ef80bf; font-weight: bold;">return</span> sqrt(d1d1 + d2d2);
}
<span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">Compute the distance from AB to C</span>
<span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">if isSegment is true, AB is a segment, not a line.</span>
<span style="color: #f470df;">double</span> <span style="color: #f59280;">linePointDist</span>(<span style="color: #f470df;">int</span>[] A, <span style="color: #f470df;">int</span>[] B, <span style="color: #f470df;">int</span>[] C, <span style="color: #f470df;">boolean</span> <span style="color: #df7fff;">isSegment</span>) {
&#9474; <span style="color: #f470df;">double</span> <span style="color: #df7fff;">dist</span> = cross(A, B, C) / distance(A, B);
&#9474; <span style="color: #ef80bf; font-weight: bold;">if</span> (isSegment) {
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">dot1</span> = dot(A, B, C);
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (dot1 &gt; 0) <span style="color: #ef80bf; font-weight: bold;">return</span> distance(B, C);
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">dot2</span> = dot(B, A, C);
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (dot2 &gt; 0) <span style="color: #ef80bf; font-weight: bold;">return</span> distance(A, C);
&#9474; }
&#9474; <span style="color: #ef80bf; font-weight: bold;">return</span> abs(dist);
}
</code></pre>
</div>
</div>
</div>
<div id="outline-container-org8dbb5d8" class="outline-3">
<h3 id="org8dbb5d8">Polygon Area</h3>
<div class="outline-text-3" id="text-org8dbb5d8">
<p>
Consider this non-convex:
</p>


<figure id="org5b8fe08">
<img src="../i/old/2022-01-19_04-59-01_screenshot.png" alt="2022-01-19_04-59-01_screenshot.png">

</figure>


<p>
To find its area we are going to start by triangulating it. That is, we are going to divide
it up into a number of triangles. In this polygon, the triangles are ABC, ACD, and ADE. But
not all of those triangles are part of the polygon! We are going to take advantage of the
signed area given by the cross product, which will make everything work out
nicely.
</p>

<p>
First, weâ€™ll take the cross product of \(AB \cdot AC\) to find the area of \(ABC\). This will
give us a negative value, because of the way in which \(A\), \(B\) and \(C\) are oriented. However,
weâ€™re still going to add this to our sum, as a negative number. Similarly, we will take the
cross product \(AC \cdot AD\) to find the area of triangle \(ACD\), and we will again get a negative
number. Finally, we will take the cross product \(AD \cdot AE\) and since these three points are
oriented in the opposite direction, we will get a positive number. Adding these three
numbers (two negatives and a positive) we will end up with a negative number, so will take
the absolute value, and that will be area of the polygon.
</p>


<p>
The reason this works is that the positive and negative number cancel each other out by
exactly the right amount. The area of \(ABC\) and \(ACD\) ended up contributing positively to the
final area, while the area of \(ADE\) contributed negatively. Looking at the original polygon,
it is obvious that the area of the polygon is the area of \(ABCD\) (which is the same as \(ABC\) +
\(ABD\)) minus the area of \(ADE\).
</p>


<pre class="code"><code><span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">(X[i], Y[i]) are coordinates of i'th point.</span>
<span style="color: #f470df;">double</span> <span style="color: #f59280;">polygonArea</span>(<span style="color: #f470df;">double</span> <span style="color: #df7fff;">X</span>[], <span style="color: #f470df;">double</span> <span style="color: #df7fff;">Y</span>[], <span style="color: #f470df;">int</span> <span style="color: #df7fff;">n</span>)
{
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">Initialize area</span>
&#9474;   <span style="color: #f470df;">double</span> <span style="color: #df7fff;">area</span> = 0.0;
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">Calculate value of shoelace formula</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">j</span> = n - 1;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #f470df;">int</span> <span style="color: #df7fff;">i</span> = 0; i &lt; n; i++)
&#9474;   {
&#9474;   &#9474;   area += (X[j] + X[i]) * (Y[j] - Y[i]);
&#9474;   &#9474;   j = i;  <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">j is previous vertex to i</span>
&#9474;   }
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">Return absolute value</span>
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> abs(area / 2.0);
}
</code></pre>
</div>
</div>
</div>
<div id="outline-container-orgc7d17dd" class="outline-2">
<h2 id="orgc7d17dd">Intersection</h2>
<div class="outline-text-2" id="text-orgc7d17dd">
<p>
The first thing to think about in line-line intersection problem is what form we given our
lines in, and what form would we like them in? In the best cases, each line will be in such
a form: \(A_{x} + B_{y} = C\) where \(A\), \(B\), and \(C\), are the numbers which define the line.
We can generate any equation between two points easily. Say we are given two different
points \((x_{1}, y{1})\) and \((x_{2}, y{2})\) and we what to find \(A\), \(B\) and \(C\) for the
equation above, we can easily say:
</p>

\begin{equation*}
a= y_2 - y_1
\end{equation*}

\begin{equation*}
b= x_1 - x_2
\end{equation*}

\begin{equation*}
c= ax_1+by_1
\end{equation*}

<p>
Since this is one of the most problems I noticed people have trouble with, let&rsquo;s try to
simplify more than that, consider the following equation:
</p>

\begin{equation}
y= \underbrace{m}_{slope} \times \overbrace{x}^{x \ coordinate} + \underbrace{y}_{y \
intercept} \end{equation}

<p>
This basic formula is called <i>slope-intercept form</i>:
</p>


<figure id="orga77c7f1">
<img src="../i/old/2022-01-19_04-59-48_screenshot.png" alt="2022-01-19_04-59-48_screenshot.png">

</figure>

<p>
From the figure you can notice that the line crosses the \(y\) axis at \(y = 1\), so in formula,
\(b\) (the \(y\) intercept) is 1. The slope, is the ratio of the change in the way axis for a
given change in the \(x\) axis, in this figure it&rsquo;s \(\frac{1}{2} = 0.5\), so we can tell that
the slope-intercept form for this line is \(y=.5x+1\). That&rsquo;s nice, but in code, we can&rsquo;t and
we shouldn&rsquo;t solve this visually at all.
</p>

<p>
So, we have got to, first, calculate the swap form the formula \(\frac{y_{2} - y_{1}}{x_2 -
x_1}\), here we can take
\(\frac{4-2}{6-2} = \frac{2}{4} = 0.5\), this gives us \(y = .5x + b\) now we can use each of the given point
[ \((2,2)\) or \((6,4)\) ] in this equation, let&rsquo;s take \((2,2)\), this give us: \(2=0.5 \times 2 + b\), \(2 = 1 + b\), \(b = 1\),
and we have the final
formula again: \[y = 0.5x + 1\]
</p>

<p>
Anther way to define a line is called <i>the standard form</i>: \(A_x + B_y = C\) and both \(A_x\)
and \(B_y\) should be integers, and \(A_x\) can&rsquo;t be negative. We can rearrange our final
formula to fit the standard form by reformatting it to \(-0.5x + y = 1\), you can observe that
\(A_x\) is neither positive nor integer, we can fix it by multiplying by -2: we should get:
\(x - 2y = -2\) and of course you can test it with replacing \(x\) and \(y\) by any of the given
points, the result should be equal to \(-2\).
</p>

<p>
Another nice way to get this form is that we can calculate \(A\) by this subtraction:
\(A_x =
y_2 - y_1\), and \(B_y\) is \(x_{1} - x_{2}\) and \(C\) is just \(A_x + B_y\), lets&rsquo; take the points
we have and try to apply this, we get:
</p>

<p>
\[A= 4-2 =2\]
</p>

<p>
\[B= 2-6 =-4\]
</p>

<p>
Now all what you have to do is putting these numbers in the standard form equation, and you
get:
</p>

\begin{equation*}
2x-4y=C \end{equation*}

<p>
And by replacing \(x\) and \(y\) by any of the given points, say \((2,2)\), we can solve this
equation for \(C\), it is \(-4\) so the final equation is:
</p>

\begin{equation*}
2x - 4y = -4 \end{equation*}


<p>
Now, let&rsquo;s define what we mean by intersection, let&rsquo;s say we have the following points
\(P_1,
\ P_2, \ P_3, \ P_4\) showing in the following figure:
</p>



<figure id="org994c048">
<img src="../i/old/2022-01-19_05-00-07_screenshot.png" alt="2022-01-19_05-00-07_screenshot.png">

</figure>


<p>
As these are two lines, we should have two equations for each line:
</p>
\begin{equation*}
A_{1}x + B_{1}y = C_{1} \ \ \ (P_1,P_2)
\tag{1}
\end{equation*}

\begin{equation*}
A_{2}x + B_{2}y = C_{2} \ \ \ (P_2,P_4)
\tag{2}
\end{equation*}

<p>
Now, you can notice that these line intersect in the figure, so they share an intersection
point (the red point), so we can say that there is a single value in \(x\) and \(y\) that will
exist in both of these lines and will satisfy both of their equations, so we need to solve
for \(x\) and then for \(y\). But here is a point, you can&rsquo;t solve a single equation with
multiple variables for just one of those variables, but if you have two equations that both
contain the same two variables, you can combine them in the order to solve for one of those
variable using simple algebra, let&rsquo;s combine the two equations, first let&rsquo;s
multiple both sides of the first equation by  \(B_2\)
</p>
\begin{equation*}
A_{1}B{2}x + B_{1} B_{2}y = C_{1} B_{2}
\tag{1}
\end{equation*}

<p>
And do the same with the second one but by \(B_{1}\)
</p>

\begin{equation*}
A_{2}B_{1}x + B_{1} B_{2}y = C_{2} B_{1}
\tag{2}
\end{equation*}

<p>
If we subtract the first equation from the second one, we will cancel out the second term
\(B_{1} B_{2}y\) and we are end with
</p>

\begin{equation*}
A_{1}B_{2}x - A_{2}B_{1}x  = C_{1} B_{2} - C_{2} B_{1}
\tag{3}
\end{equation*}

<p>
Here we can extract x
</p>

 \begin{equation*}
x(A_{1}B_{2} - A_{2}B_{1})  = C_{1} B_{2} - C_{2} B_{1}
\tag{4}
\end{equation*}

<p>
And now simply you are ready to solve for \(x\): \[ x = \frac{ C_1  B_2 - C_2 B_1 }{ A_1 B_2 -
A_2 B_1}\]
We can do the same thing for the \(y\) by multiplying by \(A_{1}\) and \(A_{2}\), but I&rsquo;ll save my
time and here is the final formula: \[y = \frac{A_{1} C_{2} - A_{2} C_{1}}{A_1 B_2 - A_2
B_1}\].
</p>

<p>
Now, all what we need to do is taking \(x\) and \(y\) from the original 4 points and use them to
get the \(A\), \(B\), and \(C\) for each line, and once we get this, we can calculate the
intersection point using the mentioned formulas.
</p>

<p>
Now, we can repeat easily in C:
</p>
<pre class="code"><code><span style="color: #f470df;">double</span> <span style="color: #df7fff;">det</span> = A1 * B2 - A2 * B1
<span style="color: #ef80bf; font-weight: bold;">if</span> (det == 0) {
&#9474; <span style="color: #bf9f8f; font-style: italic;">//</span><span style="color: #bf9f8f; font-style: italic;">Lines are parallel</span>
} <span style="color: #ef80bf; font-weight: bold;">else</span> {
&#9474; <span style="color: #f470df;">double</span> <span style="color: #df7fff;">x</span> = (B2 * C1 - B1 * C2) / det
&#9474; <span style="color: #f470df;">double</span> y = (A1 * C2 - A2 * C1) / det
}
</code></pre>
</div>
</div>
<div id="outline-container-org7d6a227" class="outline-2">
<h2 id="org7d6a227">Finding The Equation of a Line for a Segment</h2>
<div class="outline-text-2" id="text-org7d6a227">
<p>
Let the given segment be \(PQ\)  i.e. the known coordinates of its ends \(P_x, P_y, Q_x, Q_y\)
</p>

<p>
It is necessary to construct the equation of a line in the plane passing through this
segment, i.e. find the coefficients  \(A_x + B_y + C = 0\)  in the equation of a line:
</p>


<p>
Note that for the required triples  there are infinitely many solutions which describe the
given segment: you can multiply all three coefficients by an arbitrary non-zero number and
get the same straight line. Therefore, our task is to find one of these triples.
</p>

<p>
It is easy to verify (by substitution of these expressions and the coordinates of the points
and  into the equation of a straight line) that the following set of coefficients fits:
</p>

\begin{align}
A &= P_y - Q_y, \\
B &= Q_x - P_x, \\
C &= - A P_x - B P_y.
\end{align}
</div>
<div id="outline-container-orgb0ca7d9" class="outline-3">
<h3 id="orgb0ca7d9"><span class="done KILL">KILL</span> Real Case vs. Integer Case</h3>
</div>
</div>
<div id="outline-container-orga3d45bb" class="outline-2">
<h2 id="orga3d45bb">Orientation of 3 Points</h2>
<div class="outline-text-2" id="text-orga3d45bb">
<p>
To get the intuition of what is left and what is right turn, consider an example shown below.
</p>


<figure id="orga0a589e">
<img src="../i/old/2022-02-10_21-33-40_screenshot.png" alt="2022-02-10_21-33-40_screenshot.png">

</figure>

<p>
Given two points \(p_1(x1,y1)\) and \(p_2(x2,y2)\), we need to first determine whether point
\(p_1\) is clockwise or is anti-clockwise from point \(p2\) with respect to origin. One way of
solving this problem is by calculating the angle made by both \(\overline{p_1}\) and
\(\overline{p_2}\) with x-axis and the difference in the angle can tell whether one point is
clockwise or anti-clockwise from other. There is an easier and efficient solution to this
than finding the angle which is calculating the cross product of the vector \(\overline{p_1}\)
and \(\overline{p_2}\) mathematically the cross product of two vectors \(\overline{p_1}\) and
\(\overline{p_2}\) is given by
</p>

<p>
\(p_1 \times p_2 = x_1 y_2 - x_2 y_1\)
</p>

<p>
If the value of \(p_1 \times p_2\) is positive then \(p_1\) is clockwise from \(p_2\) with respect
to origin.
</p>

<p>
Similarly, if \(p_1 \times p_2\) is negative then p1 is anti-clockwise from \(p_2\) with respect to origin and
if the value is 0 then points \(p_1, p_2\) and origin are collinear.
</p>

<p>
respectively. In order to calculate the cross product of two segments, we need to convert
them into the vectors. This can be done in the following way.
</p>

<p>
\(\overline{p_1p_2} = (x_2 - x_1 , y_2 - y_1)\)
</p>
</div>
</div>
<div id="outline-container-org272e3d7" class="outline-2">
<h2 id="org272e3d7">Finding a Circle From 3 Points</h2>
<div class="outline-text-2" id="text-org272e3d7">
<p>
Given 3 points which are not colinear (all on the same line) those three points uniquely
define a circle. But, how do you find the center and radius of that circle? This task turns
out to be a simple application of line intersection. We want to find the perpendicular
bisectors of \(XY\) and \(YZ\), and then find the intersection of those two bisectors. This gives us
the center of the circle.
</p>


<figure id="orgc21cd6e">
<img src="../i/old/2022-01-19_05-00-24_screenshot.png" alt="2022-01-19_05-00-24_screenshot.png">

</figure>


<p>
To find the perpendicular bisector of \(XY\), find the line from \(X\) to \(Y\), in the form \(A_x+B_y=C\). A
line perpendicular to this line will be given by the equation \(-B_x+A_y=D\), for some \(D\). To find
\(D\) for the particular line we are interested in, find the midpoint between \(X\) and \(Y\) by taking
the midpoint of the x and y components independently (midpoint, \((x_m,y_m) = (\frac{x_1 +
x_2}{2}, \frac{y_1+y_2}{2})\)). Then, substitute those values into the
equation to find \(D\). If we do the same thing for Y and Z, we end up with two equations for
two lines, and we can find their intersections as described above. Also, keep in mind that
the equation of circle in general form is xÂ² + yÂ² + 2gx + 2fy + c = 0 and in radius form is
(x â€“ h)Â² + (y -k)Â² = rÂ², where (h, k) is the center of the circle and r is the radius.
</p>

<pre class="code"><code><span style="color: #f470df;">void</span> <span style="color: #f59280;">findCircle</span>(<span style="color: #f470df;">int</span> <span style="color: #df7fff;">x1</span>, <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y1</span>, <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x2</span>, <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y2</span>, <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x3</span>, <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y3</span>)
{
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x12</span> = x1 - x2;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x13</span> = x1 - x3;
&#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y12</span> = y1 - y2;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y13</span> = y1 - y3;
&#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y31</span> = y3 - y1;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">y21</span> = y2 - y1;
&#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x31</span> = x3 - x1;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">x21</span> = x2 - x1;
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">x1^2 - x3^2</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">sx13</span> = pow(x1, 2) - pow(x3, 2);
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">y1^2 - y3^2</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">sy13</span> = pow(y1, 2) - pow(y3, 2);
&#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">sx21</span> = pow(x2, 2) - pow(x1, 2);
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">sy21</span> = pow(y2, 2) - pow(y1, 2);
&#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">f</span> = ((sx13) * (x12)
&#9474;   &#9474;   &#9474;   &#9474;+ (sy13) * (x12)
&#9474;   &#9474;   &#9474;   &#9474;+ (sx21) * (x13)
&#9474;   &#9474;   &#9474;   &#9474;+ (sy21) * (x13))
&#9474;   &#9474;   &#9474;   / (2 * ((y31) * (x12) - (y21) * (x13)));
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">g</span> = ((sx13) * (y12)
&#9474;   &#9474;   &#9474;   &#9474;+ (sy13) * (y12)
&#9474;   &#9474;   &#9474;   &#9474;+ (sx21) * (y13)
&#9474;   &#9474;   &#9474;   &#9474;+ (sy21) * (y13))
&#9474;   &#9474;   &#9474;   / (2 * ((x31) * (y12) - (x21) * (y13)));
&#9474;   &#9474;   &#9474;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">c</span> = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1;
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">eqn of circle be x^2 + y^2 + 2*g*x + 2*f*y + c = 0</span>
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">where centre is (h = -g, k = -f) and radius r</span>
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">as r^2 = h^2 + k^2 - c</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">h</span> = -g;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">k</span> = -f;
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">sqr_of_r</span> = h * h + k * k - c;
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">r is the radius</span>
&#9474;   <span style="color: #f470df;">float</span> <span style="color: #df7fff;">r</span> = sqrt(sqr_of_r);
&#9474;
&#9474;   cout &lt;&lt; <span style="color: #e5b76f;">"Centre = ("</span> &lt;&lt; h &lt;&lt; <span style="color: #e5b76f;">", "</span> &lt;&lt; k &lt;&lt; <span style="color: #e5b76f;">")"</span> &lt;&lt; endl;
&#9474;   cout &lt;&lt; <span style="color: #e5b76f;">"Radius = "</span> &lt;&lt; r;
}
</code></pre>
</div>
</div>
<div id="outline-container-orge3a11c9" class="outline-2">
<h2 id="orge3a11c9">Convex Hull</h2>
<div class="outline-text-2" id="text-orge3a11c9">
<p>
A convex hull of a set of points is the smallest convex polygon that contains every one of
the points. It is defined by a subset of all the points in the original set. One way to
think about a convex hull is to imagine that each of the points is a peg sticking up out of
a board. Take a rubber band and stretch it around all of the points. The polygon formed by
the rubber band is a convex hull.
</p>
</div>
<div id="outline-container-org2681066" class="outline-3">
<h3 id="org2681066">Jarvi&rsquo;s algorithm</h3>
<div class="outline-text-3" id="text-org2681066">
<p>
\(O(n^2)\)
\(O(n \cdot h)\)
</p>

<p>
There is two approaches to solve this problem, <i>Jarvi&rsquo;s algorithm</i> and <i>Graham Scan</i>, in
this article I&rsquo;m going to use Jarvi&rsquo;s algorithm here, if you are autistic enough you can
check <a href="http://www.dcs.gla.ac.uk/~pat/52233/slides/Hull1x1.pdf">Grahm Scan</a>.
</p>

<p>
he core of Jarvi&rsquo;s algorithm is described in the following points:
</p>

<ol class="org-ol">
<li>Initialize \(p\) as leftmost point</li>
<li>Do the following as long as we don&rsquo;t come back to the leftmost point again:
<ol class="org-ol">
<li><p>
The next point \(q\) is the point such that the triple \((p,\ r,\ q)\) is counterclockwise for any other point \(r\).
</p>

<p>
To find this we simply initialize \(q\) as the next point, then we traverse through the
all points. For any point \(i\), if \(i\) is more counterclockwise, then we update \(q =
      i\).
How to check if point is more counterclockwise? We can use orientation checker:
</p>


<figure id="org13a18f4">
<img src="../i/old/2022-01-19_05-00-40_screenshot.png" alt="2022-01-19_05-00-40_screenshot.png">

</figure>

<p>
(in this figure, clockwise triplet \(ABC\): cross product of \(AB\) and \(AC\) vectors is \(> 0\) anticlockwise triplet \(ACD\): cross product of \(AC\) and \(AD\) is negative.)
</p>

<pre class="code"><code><span style="color: #f470df;">int</span> <span style="color: #f59280;">orientation</span>(<span style="color: #f470df;">Point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">Point</span> <span style="color: #df7fff;">q</span>, <span style="color: #f470df;">Point</span> <span style="color: #df7fff;">r</span>)
{
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">val</span> = (q.y - p.y) * (r.x - q.x) -
&#9474;   &#9474;   &#9474;   &#9474; (q.x - p.x) * (r.y - q.y);
&#9474;   &#9474;   &#9474;   &#9474;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (val == 0) <span style="color: #ef80bf; font-weight: bold;">return</span> 0;  <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">collinear</span>
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> (val &gt; 0)? 1: 2; <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">clock or counterclock wise</span>
}
</code></pre>

<p>
If we found that the points are collinear, we should consider taking the points with
more distance, using a distance utility
</p>

<pre class="code"><code><span style="color: #f470df;">float</span> <span style="color: #f59280;">dis</span>(<span style="color: #f470df;">point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">q</span>) {
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> sqrt(   pow(p[x] - q[x], 2) +
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   pow(p[y] - q[y] , 2) * 1.0 );
}
</code></pre></li>

<li>next[p] = q (store \(q\) as next of \(p\) in the output convex hull)</li>
<li>\(p = q\) (Set p as q for the next iteration)</li>
</ol></li>
</ol>


<p>
Now, let&rsquo;s repeat in C(++):
</p>

<pre class="code"><code><span style="color: #8fbaef;">#include</span> <span style="color: #e5b76f;">&lt;vector&gt;</span>
<span style="color: #8fbaef;">#include</span> <span style="color: #e5b76f;">&lt;iostream&gt;</span>
<span style="color: #8fbaef;">#include</span> <span style="color: #e5b76f;">&lt;cmath&gt;</span>
<span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">x</span> 0
<span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">y</span> 1
<span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">point</span> <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;
<span style="color: #ef80bf; font-weight: bold;">using</span> <span style="color: #ef80bf; font-weight: bold;">namespace</span> <span style="color: #ff78aa;">std</span>;
<span style="color: #f470df;">int</span> <span style="color: #f59280;">orinetation</span>(<span style="color: #f470df;">point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">q</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">r</span>) {
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">val</span> = (q[y] - p[y] ) * (r[x] - q[x]) -
&#9474;   &#9474;   (q[x] - p [x] ) * (r[y] - q[y]);
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (val ==0 ) <span style="color: #ef80bf; font-weight: bold;">return</span> 0; <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">collinear</span>
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> (val &gt; 0) ? 1 : 2;
&#9474;
}

<span style="color: #f470df;">float</span> <span style="color: #f59280;">dis</span>(<span style="color: #f470df;">point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">q</span>) {
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> sqrt(pow(p[x] - q[x], 2) +
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   pow(p[y] - q[y] , 2) * 1.0 );
}

<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #f59280;">jarvis_march</span>(<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #df7fff;">points</span>) {
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">n</span> = points.size();
&#9474;   <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt;<span style="color: #df7fff;">hull</span>;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (n &lt; 3) <span style="color: #ef80bf; font-weight: bold;">return</span> hull;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">find list most</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">l</span> = 0;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #f470df;">int</span> <span style="color: #df7fff;">i</span> = 1; i &lt; n; i++) {
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (points[i][x] &lt; points[l][x])
&#9474;   &#9474;   &#9474;   l = i;
&#9474;   }
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">q</span>, <span style="color: #df7fff;">left</span> = l;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">do</span> {
&#9474;   hull.push_back(points[l]);
&#9474;   q = (l+1) % n;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #f470df;">int</span> <span style="color: #df7fff;">i</span> = 0; i &lt; n; i++) {
&#9474;   &#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">direction</span> = orinetation(points[l], points[i], points[q]);
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span>(direction == 2 || ( direction == 0 &amp;&amp; dis(points[i], points[l]) &gt; dis(points[q],points[l]))  )
&#9474;   &#9474;   &#9474;   q = i;
&#9474;   }
&#9474;   l=q;
&#9474;
&#9474;   } <span style="color: #ef80bf; font-weight: bold;">while</span> (l != left );
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> hull;
}
<span style="color: #f470df;">int</span> <span style="color: #f59280;">main</span>() {
&#9474;   <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #df7fff;">po</span> { {1,4}, {3,3} , {5,5} , {9,6} , {5,2}, {0,0} , {3,1} , {7,0} };
&#9474;   <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt;<span style="color: #df7fff;">l</span> = jarvis_march(po);
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #ef80bf; font-weight: bold;">auto</span> <span style="color: #df7fff;">i</span> : l)
&#9474;   &#9474;   {
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #ef80bf; font-weight: bold;">auto</span> <span style="color: #df7fff;">k</span> : i)
&#9474;   &#9474;   &#9474;   cout &lt;&lt; k &lt;&lt; <span style="color: #e5b76f;">" "</span>;
&#9474;   &#9474;   &#9474;   &#9474;
&#9474;   &#9474;   &#9474;   &#9474;   cout &lt;&lt; endl;
&#9474;   &#9474;   }
&#9474;   &#9474;
}
</code></pre>


<p>
Python implementation:
</p>
<pre class="code"><code><span style="color: #ef80bf; font-weight: bold;">def</span> <span style="color: #f59280;">jarvis_march</span>(points):
&#9474;   <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">find the leftmost point</span>
&#9474;   <span style="color: #df7fff;">a</span> =  <span style="color: #a897ef; font-weight: bold;">min</span>(points, key = <span style="color: #ef80bf; font-weight: bold;">lambda</span> point: point.x)
&#9474;   <span style="color: #df7fff;">index</span> = points.index(a)
&#9474;
&#9474;   <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">selection sort</span>
&#9474;   <span style="color: #df7fff;">l</span> = index
&#9474;   <span style="color: #df7fff;">result</span> = []
&#9474;   result.append(a)
&#9474;   <span style="color: #ef80bf; font-weight: bold;">while</span> (<span style="color: #ff78aa;">True</span>):
&#9474;   &#9474;   <span style="color: #df7fff;">q</span> = (l + 1) % <span style="color: #a897ef; font-weight: bold;">len</span>(points)
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> i <span style="color: #ef80bf; font-weight: bold;">in</span> <span style="color: #a897ef; font-weight: bold;">range</span>(<span style="color: #a897ef; font-weight: bold;">len</span>(points)):
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> i == l:
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">continue</span>
&#9474;   &#9474;   &#9474;   <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">find the greatest left turn</span>
&#9474;   &#9474;   &#9474;   <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">in case of collinearity, consider the farthest point</span>
&#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">d</span> = direction(points[l], points[i], points[q])
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d &gt; 0 <span style="color: #ef80bf; font-weight: bold;">or</span> (d == 0 <span style="color: #ef80bf; font-weight: bold;">and</span> distance_sq(points[i], points[l]) &gt; distance_sq(points[q], points[l])):
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">q</span> = i
&#9474;   &#9474;   <span style="color: #df7fff;">l</span> = q
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> l == index:
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">break</span>
&#9474;   &#9474;   result.append(points[q])
&#9474;   &#9474;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> result
</code></pre>
<p>
A visualization:
</p>


<figure id="org2902a19">
<img src="../i/old/2022-01-19_05-01-38_Animation_depicting_the_gift_wrapping_algorithm.gif" alt="2022-01-19_05-01-38_Animation_depicting_the_gift_wrapping_algorithm.gif">

</figure>
</div>
<div id="outline-container-org8ea834a" class="outline-4">
<h4 id="org8ea834a">Trace</h4>
<div class="outline-text-4" id="text-org8ea834a">
<p>
Let&rsquo;s try to trace the C(++) program above with the very same given points in the program:
</p>



<figure id="org307c266">
<img src="../i/old/2022-01-19_05-01-56_screenshot.png" alt="2022-01-19_05-01-56_screenshot.png">

</figure>

<p>
The program first finds the leftmost point by sorting the points on x-coordinates. The
leftmost point for the above set of points is \(l=(0,0)\). We insert the point \((0,0)\) into the
convex hull vertices as shown by the green circle in the figure below.
</p>


<figure id="orgbd19f90">
<img src="../i/old/2022-01-19_05-02-14_screenshot.png" alt="2022-01-19_05-02-14_screenshot.png">

</figure>


<p>
Next we find the left most point from point \(l=(0,0)\). The step by step process of finding the
left most point from \(l=(0,0)\) is given below.
</p>

<ol class="org-ol">
<li>We pick a point following \(l\) and call it \(q\). Let \(q\) be the point \((3,3)\) (You can pick any point, generally we pick next of \(l\) in array of points).</li>

<li>Let all other points except \(l\) and \(q\) be \(i\). Now we check whether the sequence of points (\(l,i,q)\) turns right. If it turns right, we replace \(q\) by \(i\) and repeat the same process for remaining points.</li>

<li>Let \(i=(7,0)\). The sequence \(((0, 0), (7, 0), (3, 3))\) turns left. Since we only care about right turn, we donâ€™t do anything in this case and simply move on.</li>

<li>Let next \(i=(3,1)\). The sequence \(((0, 0), (3, 1), (3, 3))\) turns left and we move on without doing anything.</li>

<li>Let next \(i=(5,2)\). The sequence \(((0, 0), (5, 2), (3, 3))\) again turns left and we move on.</li>

<li>Next \(i=(5,5)\). The sequence \(((0, 0), (5, 2), (3, 3))\) is collinear. In the case of collinear, we replace \(q\) with \(i\) only if distance between \(l\) and \(i\) is greater than distance between \(q\) and \(l\). In this case the distance between \((0,0)\) and \((5,5)\) is greater than the distance between \((0,0)\) and \((3,3)\) we replace q with point \((5,5)\).</li>

<li>Let next \(i=(1,4)\). The sequence \(((0, 0), (1, 4), (5, 5))\) turns right. We replace \(q\) by point \((1,4)\).</li>

<li>Finally the only choice for \(i\) is \((9,6)\). The sequence \(((0, 0), (9, 6), (1, 4))\) turns left. So we do nothing. We went through all the points and now \(q=(1,4)\) is the left most point.</li>
</ol>

<p>
We add point \((1,4)\) to the convex hull.
</p>


<figure id="org17e88af">
<img src="../i/old/2022-01-19_05-02-31_screenshot.png" alt="2022-01-19_05-02-31_screenshot.png">

</figure>

<p>
Next, we find the leftmost point from the point \((1,4)\) following the steps 1 - 8 mentioned
above. If we follow all the steps, the leftmost point will be \((9,6)\).
</p>



<figure id="org9e79f36">
<img src="../i/old/2022-01-19_05-02-42_screenshot.png" alt="2022-01-19_05-02-42_screenshot.png">

</figure>



<p>
Using the same process, the leftmost point from \((9,6)\) will be the point \((7,0)\).
</p>


<figure id="orgea9d49e">
<img src="../i/old/2022-01-19_05-02-53_screenshot.png" alt="2022-01-19_05-02-53_screenshot.png">

</figure>


<p>
Finally from \((7,0)\) we compute the leftmost point. The leftmost point from \((7,0)\) will be the point \((0, 0)\). Since \((0,0)\) is already in the convex hull, the algorithm stops.
</p>
</div>
</div>
<div id="outline-container-orgcd4ebd2" class="outline-4">
<h4 id="orgcd4ebd2">Complexity</h4>
<div class="outline-text-4" id="text-orgcd4ebd2">
<p>
The algorithm spends \(O(n)\) time on each convex hull vertex. If there are h convex hull
vertices, the total time complexity of the algorithm would be \(O(nh)\). Since h is the number
of output of the algorithm, this algorithm is also called output sensitive algorithm since
the complexity also depends on the number of output.
</p>
</div>
</div>
<div id="outline-container-orgfce5ca1" class="outline-4">
<h4 id="orgfce5ca1">Further Reading</h4>
<div class="outline-text-4" id="text-orgfce5ca1">
<ul class="org-ul">
<li>Briquet, C. (n.d.). Introduction to Convex Hull Applications. Lecture. Retrieved August 23, 2018, from <a href="http://www.montefiore.ulg.ac.be/~briquet/algo3-chull-20070206.pdf">http://www.montefiore.ulg.ac.be/~briquet/algo3-chull-20070206.pdf</a></li>
<li>Erickson, J. (n.d.). Convex Hulls. Lecture. Retrieved August 23, 2018, from <a href="http://jeffe.cs.illinois.edu/teaching/373/notes/x05-convexhull.pdf">http://jeffe.cs.illinois.edu/teaching/373/notes/x05-convexhull.pdf</a></li>
<li>Mount, D. M. (n.d.). CMSC 754 Computational Geometry. Lecture. Retrieved August 23, 2018, from <a href="https://www.cs.umd.edu/class/spring2012/cmsc754/Lects/cmsc754-lects.pdf">https://www.cs.umd.edu/class/spring2012/cmsc754/Lects/cmsc754-lects.pdf</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2923c40" class="outline-3">
<h3 id="org2923c40">Grahm Scan</h3>
<div class="outline-text-3" id="text-org2923c40">
<p>
\(O(n \cdot log(n))\)
</p>

<p>
Graham scan is an algorithm to compute a convex hull of a given set of points in \(O(n\log n)\)
time. This algorithm first sorts the set of points according to their polar angle and scans
the points to find the convex hull vertices.
</p>

<p>
The step by step working of a Graham Scan Algorithms on the point set \(P\) is given below.
</p>

<ol class="org-ol">
<li>Find the point \(P_0\) with the smallest \(y\) -coordinate. In some cases of tie, choose the point with smallest \(x\) coordinate.</li>

<li><p>
Sort the points based on the polar angle i.e. the angle made by the line with the \(x\) -axis. While implementing, we donâ€™t calculate the angle, instead, we calculate the relative orientation of two points to find out which point makes the larger angle. This can be explained with the help of a figure shown below.
</p>


<figure id="org3d32a57">
<img src="../i/old/2022-01-19_05-03-08_screenshot.png" alt="2022-01-19_05-03-08_screenshot.png">

</figure></li>
</ol>


<p>
To find out whether the line \(P_0 P_1\) or the line \(P_0 P_3\) makes the larger angle with the
\(x\) -axis, we calculate the cross-product of vector \(P_1 P_0\) and vector
\(P_1 P_3\) If the cross-product is positive, that means vector \(P_1 P_0\) is
clockwise from vector \(P_1 P_3\) with respect to the \(x\) -axis. This indicates that the
angle made by the vector \(P_1 P_3\) is larger. We can use any sorting algorithm that
has complexity \(O(n \log n)\).
</p>


<figure id="orge6deefa">
<img src="../i/old/2022-01-19_05-03-21_screenshot.png" alt="2022-01-19_05-03-21_screenshot.png">

</figure>


<p>
Remainder, to convert a point into a vector we use \[\overline{p_1p_2} = (x_2 - x_1,
   y_2 - y_1), \overline{p_1p_3} = (x_3 - x_1, y_3 - y_1)\]
</p>

<p>
It looks like this:
</p>


<figure id="org481cedb">
<img src="../i/old/2022-01-19_05-03-40_screenshot.png" alt="2022-01-19_05-03-40_screenshot.png">

</figure>

<ol class="org-ol">
<li>After sorting, we check for the collinear points. If we find any collinear points, we keep the furthest point from \(P0\) and remove all other points. This step takes \(O(n)\) time.</li>
<li>First two points in the sorted list are always in the convex hull. In the above figure, points \(P_0\) and \(P_1\) are the vertices of the convex hull. We maintain a stack data structure to keep track of the convex hull vertices. We push these two points and the next point in the list (points \(P_0\),\(P_1\) and \(P_3\) in the figure above) to the stack.</li>
<li>Now we check if the next point in the list turns left or right from the two points on the top of the stack. If it turns left, we push this item on the stack. If it turns right, we remove the item on the top of the stack and repeat this process for remaining items. This step takes \(O(n)\) times.</li>
</ol>

<p>
If we perform these steps on a set of points, we should get correct convex hull.
</p>

<p>
Let&rsquo;s repeat in C(++):
</p>

<pre class="code"><code><span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">x</span> 0
<span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">y</span> 1
<span style="color: #8fbaef;">#define</span> <span style="color: #df7fff;">point</span> <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;
<span style="color: #ef80bf; font-weight: bold;">using</span> <span style="color: #ef80bf; font-weight: bold;">namespace</span> <span style="color: #ff78aa;">std</span>;
<span style="color: #f470df;">int</span> <span style="color: #f59280;">orinetation</span>(<span style="color: #f470df;">point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">q</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">r</span>) {
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">val</span> = (q[y] - p[y] ) * (r[x] - q[x]) -
&#9474;   &#9474;   (q[x] - p [x] ) * (r[y] - q[y]);
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (val ==0 ) <span style="color: #ef80bf; font-weight: bold;">return</span> 0; <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">collinear</span>
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> (val &gt; 0) ? 1 : 2; <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">clockwise : counterclockwise</span>
}

<span style="color: #f470df;">float</span> <span style="color: #f59280;">dis</span>(<span style="color: #f470df;">point</span> <span style="color: #df7fff;">p</span>, <span style="color: #f470df;">point</span> <span style="color: #df7fff;">q</span>) {
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> sqrt(   pow(p[x] - q[x], 2) +
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   pow(p[y] - q[y] , 2) * 1.0 );
}

<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #f59280;">jarvis_march</span>(<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #df7fff;">points</span>) {
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">n</span> = points.size();
&#9474;   <span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt;<span style="color: #df7fff;">hull</span>;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (n &lt; 3) <span style="color: #ef80bf; font-weight: bold;">return</span> hull;
&#9474;   <span style="color: #bf9f8f; font-style: italic;">// </span><span style="color: #bf9f8f; font-style: italic;">find left most</span>
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">l</span> = 0;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #f470df;">int</span> <span style="color: #df7fff;">i</span> = 1; i &lt; n; i++) {
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> (points[i][x] &lt; points[l][x])
&#9474;   &#9474;   &#9474;   l = i;
&#9474;   }
&#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">q</span>, <span style="color: #df7fff;">left</span> = l;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">do</span> {
&#9474;   hull.push_back(points[l]);
&#9474;   q = (l+1) % n;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #f470df;">int</span> <span style="color: #df7fff;">i</span> = 0; i &lt; n; i++) {
&#9474;   &#9474;   <span style="color: #f470df;">int</span> <span style="color: #df7fff;">direction</span> = orinetation(points[l], points[i], points[q]);
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span>(direction == 2 || ( direction == 0 &amp;&amp; dis(points[i], points[l]) &gt; dis(points[q],points[l]))  )
&#9474;   &#9474;   &#9474;   q = i;
&#9474;   }
&#9474;   l=q;
&#9474;   } <span style="color: #ef80bf; font-weight: bold;">while</span> (l != left );
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> hull;
}

<span style="color: #f470df;">int</span> <span style="color: #f59280;">main</span>() {
<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #df7fff;">pointts</span> = {{0, 3}, {2, 2}, {1, 1}, {2, 1}, {3, 0}, {0, 0}, {3, 3}};
<span style="color: #f470df;">vector</span> &lt;<span style="color: #f470df;">vector</span>&lt;<span style="color: #f470df;">int</span>&gt;&gt; <span style="color: #df7fff;">hull</span> = jarvis_march(pointts);
<span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #ef80bf; font-weight: bold;">auto</span> <span style="color: #df7fff;">i</span> : hull ) {
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> (<span style="color: #ef80bf; font-weight: bold;">auto</span> <span style="color: #df7fff;">j</span> : i ) {
&#9474;   &#9474;   cout &lt;&lt; j &lt;&lt; endl;
&#9474;   }
&#9474;   cout &lt;&lt; endl;
}

}
</code></pre>

<p>
Python implementation:
</p>
<pre class="code"><code><span style="color: #ef80bf; font-weight: bold;">def</span> <span style="color: #f59280;">find_min_y</span>(points):
&#9474;   <span style="color: #df7fff;">miny</span> = 999999
&#9474;   <span style="color: #df7fff;">mini</span> = 0
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> i, point <span style="color: #ef80bf; font-weight: bold;">in</span> <span style="color: #a897ef; font-weight: bold;">enumerate</span>(points):
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> point.y &lt; miny:
&#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">miny</span> = point.y
&#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">mini</span> = i
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> point.y == miny:
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> point.x &lt; points[mini].x:
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">mini</span> = i
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> points[mini], mini
&#9474;
<span style="color: #ef80bf; font-weight: bold;">def</span> <span style="color: #f59280;">polar_comparator</span>(p1, p2, p0):
&#9474;   <span style="color: #df7fff;">d</span> = direction(p0, p1, p2)
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d &lt; 0:
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> -1
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d &gt; 0:
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> 1
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d == 0:
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> distance_sq(p1, p0) &lt; distance_sq(p2, p0):
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> -1
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">else</span>:
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> 1
&#9474;   &#9474;   &#9474;
<span style="color: #ef80bf; font-weight: bold;">def</span> <span style="color: #f59280;">graham_scan</span>(points):
&#9474;   <span style="color: #df7fff;">p0</span>, <span style="color: #df7fff;">index</span> = find_min_y(points)
&#9474;   <span style="color: #df7fff;">points</span>[0], <span style="color: #df7fff;">points</span>[index] = points[index], points[0]
&#9474;   <span style="color: #df7fff;">sorted_polar</span> = <span style="color: #a897ef; font-weight: bold;">sorted</span>(points[1:], <span style="color: #a897ef; font-weight: bold;">cmp</span> = <span style="color: #ef80bf; font-weight: bold;">lambda</span> p1, p2: polar_comparator(p1, p2, p0))
&#9474;   <span style="color: #df7fff;">to_remove</span> = []
&#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> i <span style="color: #ef80bf; font-weight: bold;">in</span> <span style="color: #a897ef; font-weight: bold;">range</span>(<span style="color: #a897ef; font-weight: bold;">len</span>(sorted_polar) - 1):
&#9474;   &#9474;   <span style="color: #df7fff;">d</span> = direction(sorted_polar[i], sorted_polar[i + 1], p0)
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d == 0:
&#9474;   &#9474;   &#9474;   to_remove.append(i)
&#9474;   <span style="color: #df7fff;">sorted_polar</span> = [i <span style="color: #ef80bf; font-weight: bold;">for</span> j, i <span style="color: #ef80bf; font-weight: bold;">in</span> <span style="color: #a897ef; font-weight: bold;">enumerate</span>(sorted_polar) <span style="color: #ef80bf; font-weight: bold;">if</span> j <span style="color: #ef80bf; font-weight: bold;">not</span> <span style="color: #ef80bf; font-weight: bold;">in</span> to_remove]
&#9474;   <span style="color: #df7fff;">m</span> = <span style="color: #a897ef; font-weight: bold;">len</span>(sorted_polar)
&#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> m &lt; 2:
&#9474;   &#9474;   <span style="color: #a897ef; font-weight: bold;">print</span> <span style="color: #e5b76f;">'Convex hull is empty'</span>
&#9474;   &#9474;
&#9474;   <span style="color: #ef80bf; font-weight: bold;">else</span>:
&#9474;   &#9474;   <span style="color: #df7fff;">stack</span> = []
&#9474;   &#9474;   <span style="color: #df7fff;">stack_size</span> = 0
&#9474;   &#9474;   stack.append(points[0])
&#9474;   &#9474;   stack.append(sorted_polar[0])
&#9474;   &#9474;   stack.append(sorted_polar[1])
&#9474;   &#9474;   <span style="color: #df7fff;">stack_size</span> = 3
&#9474;   &#9474;
&#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">for</span> i <span style="color: #ef80bf; font-weight: bold;">in</span> <span style="color: #a897ef; font-weight: bold;">range</span>(2, m):
&#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">while</span> (<span style="color: #ff78aa;">True</span>):
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">d</span> = direction(stack[stack_size - 2], stack[stack_size - 1], sorted_polar[i])
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">if</span> d &lt; 0: <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">if it makes left turn</span>
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">break</span>
&#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #ef80bf; font-weight: bold;">else</span>: <span style="color: #bf9f8f; font-style: italic;"># </span><span style="color: #bf9f8f; font-style: italic;">if it makes non left turn</span>
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   stack.pop()
&#9474;   &#9474;   &#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">stack_size</span> -= 1
&#9474;   &#9474;   &#9474;   stack.append(sorted_polar[i])
&#9474;   &#9474;   &#9474;   <span style="color: #df7fff;">stack_size</span> += 1
&#9474;   <span style="color: #ef80bf; font-weight: bold;">return</span> stack
</code></pre>
</div>
</div>
<div id="outline-container-c8a188da-1279-4cc2-a069-b5b7bb0b9633" class="outline-3">
<h3 id="c8a188da-1279-4cc2-a069-b5b7bb0b9633"><span class="done KILL">KILL</span> Monotone chain</h3>
<div class="outline-text-3" id="text-org8e8be82">
<p>
\(O(n \cdot log(n))\)
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr style="
    clear: both;
">

<p> I seek refuge in God, from Satan the rejected. Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.1 (<a href="https://orgmode.org">Org</a> mode 9.7.31). Written by: Salih Muhammed, by the date of: 2021-12-18 Sat 05:40. Last build date: 2025-06-28 Sat 18:37.</p>

</div>
</div>
</div>
</body>
</html>
