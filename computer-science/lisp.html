<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lisp Programming Language</title>
<meta name="author" content="Salih Muhammed" />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<link rel="stylesheet" href="/style/main.css"/>


<script async data-id="101390423" src="//static.getclicky.com/js"></script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/101390423ns.gif" /></p></noscript>

<script>
  window.onload = function() {
    // get the current URL path
    var path = window.location.pathname;

    // select all navigation links
    var links = document.querySelectorAll('#preamble .center li a');

    // iterate through each link and replace the link with a span if it matches the current path
    links.forEach(function(link) {
      // compare the link's href attribute with the current path
      if (link.getAttribute('href') === path) {
        var span = document.createElement('span');
        span.innerHTML = link.innerHTML;
        span.classList.add('current');
        link.parentNode.replaceChild(span, link);
      }
    });
  };
</script>

<script>
function toggleImage(link, src) {
  var container = link.nextElementSibling;
  if (container.style.display === "none") {
    container.style.display = "block";
    link.textContent = "Click here again to hide";
  } else {
    container.style.display = "none";
    link.textContent = "Click here again to display it";
  }
  event.preventDefault();
}
</script>

	<style>
		.hide {
			display: none;
		}
	</style>
	<script>
		function hideDates() {
			var dates = document.querySelectorAll('p, i');
			for (var i = 0; i < dates.length; i++) {
				var dateRegex = /\(\d{4}\/\d{2}\/\d{2}\)/g;
				if (dateRegex.test(dates[i].innerHTML)) {
					dates[i].innerHTML = dates[i].innerHTML.replace(dateRegex, '<span class="hide">$&</span>');
				}
			}
			document.getElementById("show-link").style.display = "inline";
			document.getElementById("hide-link").style.display = "none";
		}

		function showDates() {
			var dates = document.getElementsByClassName("hide");
			for (var i = 0; i < dates.length; i++) {
				dates[i].style.display = "inline";
			}
			document.getElementById("hide-link").style.display = "inline";
			document.getElementById("show-link").style.display = "none";
		}
	</script>
</head>
<body>
<div id="preamble" class="status">
<header>

</header>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Lisp Programming Language</h1>
</header><div class="PREVIEW" id="org5c5678d">
<p>
The Lisp programming language s a family of programming languages with a long
history and a distinctive, fully parenthesized prefix notation. Originally
specified in 1958, Lisp is the second-oldest high-level programming language
still in common use. Only Fortran is older, by one year. Lisp has changed since
its early days, and many dialects have existed over its history. Today, the
best-known general-purpose Lisp dialects are Common Lisp, Scheme, Racket and
Clojure.
</p>

</div>



<div id="outline-container-org2df84a9" class="outline-2">
<h2 id="org2df84a9">Choosing Implementation</h2>
<div class="outline-text-2" id="text-org2df84a9">
<p>
The first thing you have to do is to choose a Lisp implementation. This may seem
like a strange thing to have to do for folks used to languages such as Perl,
Python, Visual Basic (VB), C#, and Java. The difference between Common Lisp and
these languages is that Common Lisp is defined by its standard—there is neither
a single implementation controlled by a benevolent dictator, as with Perl and
Python, nor a canonical implementation controlled by a single company, as with
VB, C#, and Java. Anyone who wants to read the standard and implement the
language is free to do so. Furthermore, changes to the standard have to be made
in accordance with a process controlled by the standards body American National
Standards Institute (ANSI). That process is designed to keep any one entity,
such as a single vendor, from being able to arbitrarily change the standard.
Thus, the Common Lisp standard is a contract between any Common Lisp vendor and
Common Lisp programmers. The contract tells you that if you write a program that
uses the features of the language the way they’re described in the standard, you
can count on your program behaving the same in any conforming implementation.
</p>
</div>
</div>
<div id="outline-container-orgd9a1b76" class="outline-2">
<h2 id="orgd9a1b76">Hello World</h2>
<div class="outline-text-2" id="text-orgd9a1b76">
<p>
You can just pass "Hello World" (with quotes) to the Lisp REPEL and you will get
your first Hello World in Lisp.
</p>

<p>
This works because strings, like numbers, have a literal syntax that’s
understood by the Lisp reader and are self-evaluating objects: Lisp reads the
double-quoted string and instantiates a string object in memory that, when
evaluated, evaluates to itself and is then printed in the same literal syntax.
The quotation marks aren’t part of the string object in memory—they’re just the
syntax that tells the reader to read a string. The printer puts them back on
when it prints the string because it tries to print objects in the same syntax
the reader understands.
</p>

<p>
However, this may not really qualify as a “hello, world” program. It’s more like
the “hello, world” value.
</p>

<p>
You can take a step toward a real program by writing some code that as a side
effect prints the string “hello, world” to standard output. Common Lisp provides
a couple ways to emit output, but the most flexible is the <code>FORMAT</code> function.
<code>FORMAT</code> takes a variable number of arguments, but the only two required arguments
are the place to send the output and a string. You’ll see in the next chapter
how the string can contain embedded directives that allow you to interpolate
subsequent arguments into the string, à la printf or Python’s string-%. As long
as the string doesn’t contain an \~, it will be emitted as-is. If you pass t as
its first argument, it sends its output to standard output. So a <code>FORMAT</code>
expression that will print “hello, world” looks like this:
</p>


<pre class="example" id="org9c41b23">
CL-USER&gt; (format t "hello, world")
hello, world
NIL
</pre>

<p>
However, it’s still arguable whether you’ve yet written a true “program.” But
you’re getting there. And you’re seeing the bottom-up style of programming
supported by the REPL: you can experiment with different approaches and build a
solution from parts you’ve already tested.  Now that you have a simple
expression that does what you want, you just need to package it in a function.
Functions are one of the basic program building blocks in Lisp and can be
defined with a <code>DEFUN</code> expression such as this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">hello-world</span> () (format t <span style="font-style: italic;">"hello, world"</span>))
HELLO-WORLD
</pre>
</div>

<p>
At one level, this expression, like all the others you’ve seen, is just another
expression to be read, evaluated, and printed by the REPL. The return value in
this case is the name of the function you just defined and we will discuss later
why was it uppercased.
</p>
</div>
</div>
<div id="outline-container-orge2909a4" class="outline-2">
<h2 id="orge2909a4">Why Lisp?</h2>
<div class="outline-text-2" id="text-orge2909a4">
<p>
Why learn Lisp? Because it lets you do things that you can't do in other
languages. If you just wanted to write a function to return the sum of the
numbers less than n&gt; say, it would look much the same in Lisp and C:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">sum</span> (n)
   (<span style="font-weight: bold;">let</span> ((s 0))
       (<span style="font-weight: bold;">dotimes</span> (i n s)
            (incf s i))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">aum</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>){
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> , <span style="font-weight: bold; font-style: italic;">s</span> = 0;
        <span style="font-weight: bold;">for</span> ( i = 0; i &lt; n; i++)
                s += i ;
        <span style="font-weight: bold;">return</span>(s);
}
</pre>
</div>

<p>
If you only need to do such simple things, it doesn't really matter which
language you use. Suppose instead you want to write a function that takes a
number n, and returns a function that adds n to its argument:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">addn</span> (n)
    #'(<span style="font-weight: bold;">lambda</span> (x)
     (+ x n)))
</pre>
</div>

<p>
What does addn look like in C? You just can't write it.  You might be wondering,
when does one ever want to do things like this?  Programming languages teach you
not to want what they cannot provide.  You have to think in a language to write
programs in it, and it's hard to want something you can't describe. When I first
started writing programs—in Basic—I didn't miss recursion, because I didn't know
there was such a thing.  I thought in Basic. I could only conceive of iterative
algorithms, so why should I miss recursion?
</p>

<p>
Lisp is designed to be extensible: it lets you define new operators yourself.
This is possible because the Lisp language is made out of the same functions and
macros as your own programs. So it's no more difficult to extend Lisp than to
write a program in it. In fact, it's so easy (and so useful) that extending the
language is standard practice. As you're writing your program down toward the
language, you build the language up toward your program. You work bottom-up, as
well as top-down.
</p>

<p>
As programming environments grow in power, and languages become more abstract,
the Lisp style of programming is gradually replacing the old plan-and-implement
model.
</p>

<p>
In the old model, bugs are never supposed to happen. Thorough specifications,
painstakingly worked out in advance, are supposed to ensure that programs work
perfectly. Sounds good in theory. Unfortunately, the specifications are both
written and implemented by humans. The result, in practice, is that the
plan-and-implement method does not work very well.
</p>

<p>
Planning is a necessary evil. It is a response to risk: the more dangerous an
undertaking, the more important it is to plan ahead. Powerful tools decrease
risk, and so decrease the need for planning. The design of your program can then
benefit from what is probably the most useful source of information available:
the experience of implementing it.
</p>

<p>
Lisp style has been evolving in this direction since the 1960s. You can write
prototypes so quickly in Lisp that you can go through several iterations of
design and implementation before you would, in the old model, have even finished
writing out the specifications. You don't have to worry so much about design
flaws, because you discover them a lot sooner. Nor do you have to worry so much
about bugs. When you program in a functional style, bugs can only have a local
effect. When you use a very abstract language, some bugs (e.g. dangling
pointers) are no longer possible, and what remain are easy to find, because your
programs are so much shorter. And when you have an interactive environment, you
can correct bugs instantly, instead of enduring a long cycle of editing,
compiling, and testing.
</p>


<p>
Lisp style has been evolving in this direction since the 1960s. You can write
prototypes so quickly in Lisp that you can go through several iterations of
design and implementation before you would, in the old model, have even finished
writing out the specifications. You don't have to worry so much about design
flaws, because you discover them a lot sooner. Nor do you have to worry so much
about bugs. When you program in a functional style, bugs can only have a local
effect. When you use a very abstract language, some bugs (e.g. dangling
pointers) are no longer possible, and what remain are easy to find, because your
programs are so much shorter. And when you have an interactive environment, you
can correct bugs instantly, instead of enduring a long cycle of editing,
compiling, and testing.
</p>
</div>
</div>
<div id="outline-container-org133be15" class="outline-2">
<h2 id="org133be15">Lisp Specifications</h2>
<div class="outline-text-2" id="text-org133be15">
<p>
"Okay I'm convinced"
</p>
</div>

<div id="outline-container-org4babbcf" class="outline-3">
<h3 id="org4babbcf">Evaluation</h3>
<div class="outline-text-3" id="text-org4babbcf">
<p>
In Lisp, + is a function, and an expression like (+ 2 3) is a function call.
When Lisp evaluates a function call, it does so in two steps:
</p>

<ol class="org-ol">
<li>First the arguments are evaluated, from left to right. In this case, each
argument evaluates to itself, so the values of the arguments are 2 and 3,
respectively.</li>

<li>The values of the arguments are passed to the function named by the operator.
In this case, it is the + function, which returns 5.</li>
</ol>


<p>
Not all the operators in Common Lisp are functions, but most are. And function
calls are always evaluated this way. The arguments are evaluated left-to-right,
and their values are passed to the function, which returns the value of the
expression as a whole. This is called the evaluation rule for Common Lisp.
</p>


<p>
One operator that doesn't follow the Common Lisp evaluation rule is
quote. The quote operator is a special operator, meaning that it has a
distinct evaluation rule of its own. And the rule is: do nothing. The quote
operator takes a single argument, and just returns it verbatim:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">quote</span> (+ 4 5))
</pre>
</div>

<p>
For convenience, Common Lisp defines ' as an abbreviation for quote.  You can
get the effect of calling quote by affixing a ' to the front of any expression:
</p>


<div class="org-src-container">
<pre class="src src-lisp">`(+ 4 5)
</pre>
</div>

<p>
It is much more common to use the abbreviation than to write out the whole quote
expression.
</p>

<p>
Lisp provides the quote as a way of protecting expressions from evaluation. The
next section will explain how such protection can be useful.
</p>


<p>
Symbols do not (usually) evaluate to themselves, so if you want to refer to a
symbol, you should quote it, as above.
</p>

<p>
Lists are represented as zero or more elements enclosed in parentheses.  The
elements can be of any type, including lists. You have to quote lists, or Lisp
would take them for function calls:
</p>
</div>
</div>

<div id="outline-container-orgcaa8e28" class="outline-3">
<h3 id="orgcaa8e28">Data</h3>
<div class="outline-text-3" id="text-orgcaa8e28">
<p>
Lisp offers all the data types we find in most other languages, along with
several others that we don't. One data type we have used already is the
integer, which is written as a series of digits: 256. Another data type Lisp
has in common with most other languages is the string, which is represented
as a series of characters surrounded by double-quotes: "ora et labora".
Integers and strings both evaluate to themselves.
</p>

<p>
Lists are represented as zero or more elements enclosed in parentheses.
The elements can be of any type, including lists. You have to quote lists, or
Lisp would take them for function calls:
</p>


<div class="org-src-container">
<pre class="src src-lisp">`(pray sunrise)
</pre>
</div>

<p>
Notice that one quote protects a whole expression, including expressions within
it.  You can build lists by calling list. Since list is a function, its
arguments are evaluated. Here we see a call to + within a call to list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(list `my `(+ 2 3))
</pre>
</div>

<p>
We are now in a position to appreciate one of the most remarkable features
of Lisp. Lisp programs are expressed as lists. If the arguments of flexibility
and elegance did not convince you that Lisp notation is a valuable tool, this
point should. It means that Lisp programs can generate Lisp code. Lisp
programmers can (and often do) write programs to write their programs for
them.
</p>
</div>
</div>

<div id="outline-container-org90baaa3" class="outline-3">
<h3 id="org90baaa3">List Operations</h3>
<div class="outline-text-3" id="text-org90baaa3">
<p>
The function cons builds lists. If its second argument is a list, it returns a
new list with the first argument added to the front:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(cons ' a ' (b c d))
</pre>
</div>

<p>
We can build up lists by consing new elements onto an empty list. The list
function that we saw in the previous section is just a more convenient way of
consing several things onto <code>nil</code>.
</p>

<p>
The primitive functions for extracting the elements of lists are car and cdr.
The car of a list is the first element, and the cdr is everything after the
first element:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(car `(ab c))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(cdr `(ab c))
</pre>
</div>


<p>
<i>The parentheses in the cdr are for that it is probably a list, since it is
everything but the first element, but in car it is only a one element that's why
there is not parentheses</i>.
</p>

<p>
You can use combinations of car and cdr to reach any element of a list.
If you want to get the third element, you could say:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(car (cdr (cdr ' ( a b c d ) ) ) )
</pre>
</div>

<p>
However, you can do the same thing more easily by calling third :
</p>

<div class="org-src-container">
<pre class="src src-lisp">( second '( a b c d))
</pre>
</div>

<p>
There are also <code>first</code> and <code>second</code>, you can guess what is their functionality.
</p>
</div>
</div>

<div id="outline-container-org18d377a" class="outline-3">
<h3 id="org18d377a">Truth</h3>
<div class="outline-text-3" id="text-org18d377a">
<p>
In Common Lisp, the symbol t is the default representation for truth. Like
nil, t evaluates to itself. The function <code>listp</code> returns true if its argument is
a list:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(listp `(a b c))
</pre>
</div>

<p>
A function whose return value is intended to be interpreted as truth or falsity
is called a predicate. Common Lisp predicates often have names that end with p.
</p>

<p>
The simplest conditional in Common Lisp is if. It usually takes three arguments:
a test expression, a then expression, and an else expression. The test
expression is evaluated. If it returns true, the then expression is evaluated
and its value is returned. If the test expression returns false, the else
expression is evaluated and its value is returned:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">if</span> (listp '(abc))
    (+ 1 2)
    (+ 5 6))
</pre>
</div>

<p>
Like quote, if is a special operator. It could not possibly be implemented as a
function, because the arguments in a function call are always evaluated, and the
whole point of if is that only one of the last two arguments is evaluated.  The
last argument to if is optional. If you omit it, it defaults to nil.
</p>

<p>
There are <code>and</code> and <code>or</code> functions, you probably can tell what do they do.
</p>
</div>
</div>

<div id="outline-container-orga25ccf7" class="outline-3">
<h3 id="orga25ccf7">Functions</h3>
<div class="outline-text-3" id="text-orga25ccf7">
<p>
You can define new functions with defun. It usually takes three or more
arguments: a name, a list of parameters, and one or more expressions that
will make up the body of the function. Here is how we might define third:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-third</span> (x)
    (car (cdr (cdr x ))))
</pre>
</div>

<p>
Let's try to defun <code>member</code> which tells you if whether an element is a member of
function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">somemeeber</span> (obj lst)
  (<span style="font-weight: bold;">if</span> (null lst) nil
      (<span style="font-weight: bold;">if</span> (eql (car lst) obj) t
          (somemeeber obj (cdr lst)))))
</pre>
</div>


<p>
The difference between this implementation (along many other things in the
internal implementation) is that instead of evaluating the rest of the list the
that member does it, I evaluate the truth value t.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(somemeeber 3 '(1 2 3 4))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1699993" class="outline-3">
<h3 id="org1699993">I/O</h3>
<div class="outline-text-3" id="text-org1699993">
<p>
The most general output function in Common Lisp is f ormat. It takes two or more
arguments: the first indicates where the output is to be printed, the second is
a string template, and the remaining arguments are usually objects whose printed
representations are to be inserted into the template. Here is a typical example:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(format t <span style="font-style: italic;">"~A plus ~A equals ~A. ~%"</span> 2 3 ( + 2 3))
</pre>
</div>

<p>
Notice that two things get displayed here. The first line is displayed by
format. The second line is the value returned by the call to format, displayed
in the usual way by the toplevel. Ordinarily a function like format is not
called directly from the toplevel, but used within programs, so the return
value is never seen.
</p>


<p>
The first argument to format, t, indicates that the output is to be sent to the
default place. Ordinarily this will be the toplevel. The second argument is a
string that serves as a template for output. Within this string, each ~A
indicates a position to be filled, and the ~% indicates a newline. The positions
are filled by the values of the remaining arguments, in order.
</p>


<p>
The standard function for input is read. When given no arguments, it
reads from the default place, which will usually be the toplevel. Here is a
function that prompts the user for input, and returns whatever is entered:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">askem</span> (string)
  (format t <span style="font-style: italic;">""</span>A<span style="font-style: italic;">" string)</span>
<span style="font-style: italic;">    (read))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org9485f26" class="outline-3">
<h3 id="org9485f26">Variables</h3>
<div class="outline-text-3" id="text-org9485f26">
<p>
One of the most frequently used operators in Common Lisp is <code>let</code> , which
allows you to introduce new local variables.
</p>


<p>
A <code>let</code> expression has two parts. First comes a list of instructions for
creating variables, each of the form (variable expression). Each variable will
initially be set to the value of the corresponding expression.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">ask-for-number</span> ()
  (format t <span style="font-style: italic;">"Enter a number"</span>)
  (<span style="font-weight: bold;">let</span> ((n (read)))
    (<span style="font-weight: bold;">if</span> (numberp n)
        n
        (ask-for-number))))
</pre>
</div>

<p>
You can create a global variable by giving a symbol and a value to
<code>defparameter</code>:
</p>

<p>
Such a variable will then be accessible everywhere, except in expressions that
create a new local variable with the same name. To avoid the possibility of
this happening by accident, it's conventional to give global variables names
that begin and end with asterisks. The name of the variable we just created
would be pronounced "star-glob-star".
</p>

<p>
You can also define global constants, by calling def constant:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defconstant</span> <span style="font-weight: bold; font-style: italic;">limit</span> (+ *glob* 1))
</pre>
</div>


<p>
There is no'need to give constants distinctive names, because it will cause
an error if anyone uses the same name for a variable. If you want to check
whether some symbol is the name of a global variable or constant, use boundp:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defconstant</span> <span style="font-weight: bold; font-style: italic;">*glob*</span> 43)
(boundp '*glob*)
</pre>
</div>
</div>
</div>
<div id="outline-container-org016da39" class="outline-3">
<h3 id="org016da39">Assignment</h3>
<div class="outline-text-3" id="text-org016da39">
<p>
In Common Lisp the most general assignment operator is setf. We can use
it to do assignments to either kind of variable:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf *glob* 90)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">read-number-and-prefix-with-message</span> ()
  (<span style="font-weight: bold;">let</span> ((n (ask-for-number)))
    (setf n (+ n 1))
    (format t <span style="font-style: italic;">"The new number is ~A"</span> n)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfcbbb40" class="outline-3">
<h3 id="orgfcbbb40">Iteration</h3>
<div class="outline-text-3" id="text-orgfcbbb40">
<p>
When we want to do something repeatedly, it is sometimes more natural to
use iteration than recursion. A typical case for iteration is to generate some
sort of table. This function
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">show-squares</span> (start end)
  (<span style="font-weight: bold;">do</span> ((i start (+ i 1)))
      ((&gt; i end) 'done)
    (format t <span style="font-style: italic;">"~A ~A~%"</span> i (* i i))))
(show-squares 2 4)
</pre>
</div>

<p>
The <code>do</code> macro is the fundamental iteration operator in Common Lisp.  Like <code>let</code> ,
do can create variables, and the first argument is a list of variable
specifications. Each element of this list can be of the form
</p>

<pre class="example" id="org907a8d4">
{variable initial update)
</pre>

<p>
where variable is a symbol, and initial and update are expressions. Initially
each variable will be set to the value of the corresponding initial, on each
iteration it will be set to the value of the corresponding update. The do in
show-squares creates just one variable, i . On the first iteration i will be set
to the value of <code>start</code> , and on successive iterations its value will be
incremented by one.
</p>


<p>
The remaining arguments to do comprise the body of the loop. They will be
evaluated, in order, on each iteration. On each iteration the variables are
updated, then the termination test is evaluated, and then (if the test failed)
the body is evaluated.
</p>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">show-squares</span> (i end)
 (<span style="font-weight: bold;">if</span> (&gt; i end)
  'done
  (<span style="font-weight: bold;">progn</span>
     (format t M~A ~A~&#176;/,n i (* i i ) )
   (show-squares (+ i 1) e n d))))
</pre>
</div>


<p>
Common Lisp has simpler iteration operators for special cases. To iterate
through the elements of a list, for example, you would be more likely to use
<code>dolist</code> . Observe the following functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-length-without-do</span> (lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      0
      (+ (our-length-without-do (cdr lst)) 1)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c518dc" class="outline-3">
<h3 id="org8c518dc">Functions as Objects</h3>
<div class="outline-text-3" id="text-org8c518dc">
<p>
In Lisp, functions are regular objects, like symbols or strings or lists. If we
give the name of a function to function, it will return the associated object.
Like quote, function is a special operator, so we don't have to quote the
argument:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(function +)
</pre>
</div>

<p>
You can replace the <code>+</code> with any other operator or function like <code>read</code>.
</p>

<p>
This strange-looking return value is the way a function might be displayed in a
typical Common Lisp implementation.
</p>

<p>
Until now we have only dealt with objects that look the same when Lisp displays
them as when we typed them in. This convention does not apply to functions.
Internally, a built-in function like + is likely to be a segment of machine
language code. A Common Lisp implementation may choose whatever external
representation it likes.
</p>

<p>
Just as we can use <code>'</code> as an abbreviation for quote, we can use <code>#'</code> as an
abbreviation for function:
</p>

<pre class="example" id="org689ab51">
(apply #'+ l) ==  (apply (function +) l)
</pre>

<p>
<code>#'</code> (aka function) can be used in front of (<code>lambda</code> &#x2026;) (we will talk about
lambda soon) but it's redundant there, so the only place where it's really
meaningful is in front of a symbol, as in <code>#'car</code>. In ELisp, <code>#'car</code> and <code>'car</code>
are almost completely equivalent, so one of the main purpose is simply to
document the intention (i.e. to indicate to whoever reads this code that you
intend to use this symbol as a function). Yet there are a few circumstances,
where the difference is more significant:
</p>

<ul class="org-ul">
<li>The byte-compiler takes advantage of this documented intention and when you
write <code>#'car</code> it will check whether car exists as a function, and if it doesn't
find it, it will emit a warning, just like it would if you had a call to that
function.</li>
<li><p>
Inside <code>cl-flet</code> and <code>cl-labels</code>, only <code>#'f</code> can refer to the locally defined
function <code>f</code>, because <code>'f</code> will still refer to the global symbol <code>f</code> (and
whichever function might be stored in its symbol-function slot). E.g.
</p>

<pre class="example" id="org7d74959">
(cl-flet ((car (x y) (+ x y)))
  (list #'car 'car))
=&gt;
((closure nil (x y) (+ x y)) car)
</pre>

<p>
(<a href="https://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html">read: Get in the habit of using sharp quote</a>)
</p></li>
</ul>

<p>
Like any other kind of object, we can pass functions as arguments. One function
that takes a function as an argument is apply. It takes a function and a list of
arguments for it, and returns the result of applying the function to the
arguments:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(apply #'+ ' ( 1 2 3))
</pre>
</div>


<p>
The function f u n c a l l does the same thing but does not need the arguments
to be packaged in a list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(funcall #'+ 1 2 3)
</pre>
</div>

<p>
The <code>defun</code> macro creates a function and gives it a name. But functions don't
have to have names, and we don't need def un to define them. Like most other
kinds of Lisp objects, we can refer to functions literally.
</p>

<p>
To refer literally to an integer, we use a series of digits; to refer literally
to a function, we use what's called a lambda expression. A lambda expression is
a list containing the symbol lambda, followed by a list of parameters, followed
by a body of zero or more expressions.
</p>


<p>
Here is a lambda expression representing a function that takes two numbers and
returns their sum:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">lambda</span> (x y)
  (+ x y))
</pre>
</div>

<p>
A lambda expression can be considered as the name of a function. Like an
ordinary function name, a lambda expression can be the first element of a
function call, for example:
</p>

<div class="org-src-container">
<pre class="src src-lisp">((<span style="font-weight: bold;">lambda</span> (x) (+ x 100)) 2)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8bec1f" class="outline-3">
<h3 id="orga8bec1f">Types</h3>
<div class="outline-text-3" id="text-orga8bec1f">
<p>
Lisp has an unusually flexible approach to types. In many languages, variables
are what have types, and you can't use a variable without specifying its type.
In Common Lisp, values have types, not variables. You could imagine that every
object had a label attached to it, identifying its type. This approach is called
manifest typing. You don't have to declare the types of variables, because any
variable can hold objects of any type.
</p>

<p>
(read more about <a href="https://wiki.c2.com/?ManifestTyping">manifest typing</a>)
</p>

<p>
We will study types in details later.
</p>
</div>
</div>
</div>
<div id="outline-container-org379a9a3" class="outline-2">
<h2 id="org379a9a3">Lists</h2>
<div class="outline-text-2" id="text-org379a9a3">
<p>
In Lisp, lists are one of the fundamental data structures in Lisp. In the
earliest dialects they were the only data structure: the name "Lisp" originally
stood for "LISt Processor." But Lisp has long since outgrown this acronym.
Common Lisp is a general-purpose programming language with a wide variety of
data structures.
</p>
</div>

<div id="outline-container-org10286e7" class="outline-3">
<h3 id="org10286e7">Conses</h3>
<div class="outline-text-3" id="text-org10286e7">
<p>
We previously introduced <code>cons</code>, <code>car</code>, and <code>cdr</code>, the primitive list
manipulation functions, what cons really does is combine two objects into a
two-part objects into a two-part object called <code>cons</code>.  Conceptually, a cons is
a pair of pointers; the first one is the car and the second is the <code>cdr</code>.
</p>



<p>
Conses provide a convenient representation for pairs of any type. The two halves
of a cons can point to any kind of object, including conses. It is by taking
advantage of the latter possibility that we use conses to build lists.  One does
not tend to think of lists as pairs, but they can be defined that way. Any
nonempty list can be considered as a pair of the first element and the rest of
the list.
</p>

<p>
Lisp lists are the embodiment of this idea. We use one half of the cons to point
to the first element of the list, and the other to point to the rest of the list
(which is either another cons or <code>nil</code>). The convention in Lisp has always been
to use the car for the first element and the cdr for the rest of the list. So
now car is synonymous with the first element of a list, and cdr with the rest.
Lists are not a distinct kind of object, but conses linked together in this way.
</p>


<p>
The last two lists we made both have three elements; it just happens that the
second element of z is also a list. Such a list is called a nested list, while a
list like y that doesn't contain other lists as elements is called a flat list.
</p>

<p>
The function <code>consp</code> returns true if its argument is a cons. So l i s t p could
be defined:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-listp</span> (x)
   (or (null x) (consp x)))
</pre>
</div>


<p>
Since everything that is not a cons is an atom, the predicate atom could be
defined:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-atom</span> (x) (not (consp x )))
</pre>
</div>
</div>

<div id="outline-container-org03a28ab" class="outline-4">
<h4 id="org03a28ab">Equality</h4>
<div class="outline-text-4" id="text-org03a28ab">
<p>
Each time you call cons, Lisp allocates a new piece of memory with room
for two pointers. So if we call cons twice with the same arguments, we get
back two values that look the same, but are in fact distinct objects:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(eql (cons 'a nil) (cons 'a nil) )
</pre>
</div>

<p>
<code>equal</code>, essentially, returns true if its arguments would print the same:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(equal (cons 'a nil) (cons 'a nil) )
</pre>
</div>
</div>
</div>
<div id="outline-container-org63a2db4" class="outline-4">
<h4 id="org63a2db4">Pointers</h4>
<div class="outline-text-4" id="text-org63a2db4">
<p>
One of the secrets to understanding Lisp is to realize that variables have
values in the same way that lists have elements. As conses have pointers to
their elements, variables have pointers to their values.
</p>

<p>
You may have used other languages in which pointers were manipulated explicitly.
In Lisp you never have to do this, because the language handles pointers for
you. We've already seen how this happens with lists. Something
</p>

<p>
similar happens with variables. Suppose, for example, we set two variables to
the same list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf y (list 'a 'b 'c))
(setf x '( a b c))
</pre>
</div>

<p>
What actually happens when we set y to the value of x? The location in
memory associated with the variable x does not contain the list itself, but a
pointer to it. When we assign the same value to y, Lisp copies the pointer, not
the list. So whenever you assign
one variable the value of another, the two variables will have e q l values:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf y (list 'a 'b 'c))
(setf x '( a b c))
(setf y x)
(eql x y)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbc30fed" class="outline-3">
<h3 id="orgbc30fed">Example: Compression</h3>
<div class="outline-text-3" id="text-orgbc30fed">
<p>
As an example, this section shows how to perform a simple form of compression on
lists. This algorithm goes by the impressive name of <code>run-length</code>, it should
work as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(comprs '(a a a c))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">comprs</span> (x)
  (ucompr (car x) 1 (cdr x)))


(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">ucompr</span> (elmnt n lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      (list (build elmnt n))
      (<span style="font-weight: bold;">let</span> ((next (car lst)))
        (<span style="font-weight: bold;">if</span> (eql next elmnt)
            (ucompr elmnt (+ n 1) (cdr lst))
            (cons (build elmnt n) (ucompr next 1 (cdr lst)))))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">build</span> (elmnt n)
  (<span style="font-weight: bold;">if</span> (&gt; n 1)
      (list n elmnt)
      elmnt))
</pre>
</div>



<p>
Can you write one to do uncompress?
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unbuild</span> (n elmt)
  (<span style="font-weight: bold;">if</span> (zerop n)
      nil
      (cons elmt (unbuild (- n 1) elmt))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">uncompress</span> (lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      nil
      (<span style="font-weight: bold;">if</span> (listp (car lst))
          (<span style="font-weight: bold;">let</span> ((f (car (car lst)))
                (s (cdr (car lst))))
            (cons (unbuild f s)
                  (uncompress (cdr lst))))
          (uncompress (cdr lst)))))
</pre>
</div>


<p>
This will work, however, as you will see we are going to get some different kind
of lists, lists of lists;
</p>

<div class="org-src-container">
<pre class="src src-lisp">(uncompress (list '(3 A) '(3 B) '(2 C)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0e011b" class="outline-3">
<h3 id="orgb0e011b">Access</h3>
<div class="outline-text-3" id="text-orgb0e011b">
<p>
Common Lisp has additional access functions defined in terms of <code>car</code> and
<code>cdr</code>. To find the element at a given position in a list we call <code>nth</code>,
</p>

<div class="org-src-container">
<pre class="src src-lisp">(nth 0 ' ( a b c))
</pre>
</div>

<p>
and to find the nth cdr, we call <code>nthcdr</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(nthcdr 2 ' ( a b c))
</pre>
</div>


<p>
Both <code>nth</code> and <code>nthcdr</code> are zero-indexed; that is, the elements are numbered
starting at zero rather than one. In Common Lisp, whenever you use a number
to refer to an element of a data structure, the numbering starts at zero.
The two functions do almost the same thing; <code>nth</code> is equivalent to car of
nthcdr.
</p>
</div>
</div>

<div id="outline-container-org99617b3" class="outline-3">
<h3 id="org99617b3">Mapping functions</h3>
<div class="outline-text-3" id="text-org99617b3">
<p>
Common Lisp provides several functions for calling functions on the elements
of a list. The most frequently used is mapcar, which takes a function and
one or more lists, and returns the result of applying the function to elements
taken from each list, until some list runs out:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(mapcar #'(<span style="font-weight: bold;">lambda</span> (x) (+ x 10))
         '(1 2 3))
</pre>
</div>

<p>
The related <code>maplist</code> takes the same arguments, but calls the function on
successive <code>cdrs</code> of the lists:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(maplist #'(<span style="font-weight: bold;">lambda</span> (x) x)
          '(a b c))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac7c5e1" class="outline-3">
<h3 id="orgac7c5e1">Trees</h3>
<div class="outline-text-3" id="text-orgac7c5e1">
<p>
Conses can also be considered as binary trees, with the car representing the
right subtree and the cdr the left. For example, the list
</p>
<pre class="example" id="org120ad2e">
(a (b c) d)
</pre>

<p>
is also the tree represented in the following figure:
</p>


<figure id="org5147b12">
<img src="https://link.storjshare.io/raw/jv5m4jpzayuqdz3nr2gnqwf22f4q/blog/public/org-media/mar23/2023-03-05_17-47.png" alt="2023-03-05_17-47.png">

</figure>

<p>
Binary trees without interior nodes are not useful for much. Common Lisp
includes functions for operating on trees not because one needs trees as such,
but because one needs a way to do something to a list and all the lists within
it. For example, suppose we have a list like
</p>

<div class="org-src-container">
<pre class="src src-lisp">(and (integerp x) (zerop (mod x 2)))
</pre>
</div>

<p>
and we want to substitute y for x throughout. It won't do to call substitute,
which replaces elements in a sequence:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(substitute 'y 'x '(and (integerp x) (zerop (mod x 2))))
</pre>
</div>

<p>
As you can see, this call is ineffective because <code>substitute</code> looks for
sequential elements, like this:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(substitute 'y 'x '(x (integerp x) (zerop (mod x 2))))
</pre>
</div>
<p>
However, there is a good replacement which is <code>subset</code>, which can access
subtrees:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(subst 'y 'x '(and (integerp x) (zerop (mod x 2))))
</pre>
</div>
<p>
(AND (INTEGERP Y) (ZEROP (MOD Y 2)))
</p>
</div>
</div>
<div id="outline-container-orgf2ad121" class="outline-3">
<h3 id="orgf2ad121">Sequences</h3>
<div class="outline-text-3" id="text-orgf2ad121">
<p>
Another way to think of a list is as a series of objects in a particular order.
In Common Lisp, sequences include both lists and vectors.
</p>

<p>
To copy part of a sequence, we use <code>subseq</code>. The second argument (required) is
the position of the first element to be included, and the third argument
(optional) is the position of the first element not to be included.
</p>

<p>
The function <code>reverse</code> returns a sequence with the same elements as its
argument, but in the reverse order:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(reverse '(a b c))
</pre>
</div>

<p>
Common Lisp has a built-in sort function called <code>sort</code>. It takes a sequence and
a comparison function of two arguments, and returns a sequence with the same
elements, sorted according to the function:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(sort '( 0 2 1 3 8 ) #'&gt;)
</pre>
</div>

<p>
You have to be careful when using <code>sort</code> , because it's destructive. For
efficiency reasons, <code>sort</code> is allowed to modify the sequence given to it as an
argument. So if you don't want your original sequence modified, pass a copy.
</p>
</div>
</div>
<div id="outline-container-orgd553894" class="outline-3">
<h3 id="orgd553894">Dotted Pair Notation</h3>
<div class="outline-text-3" id="text-orgd553894">
<p>
Dotted pair notation is a general syntax for cons cells that represents the CAR
and CDR explicitly. In this syntax, <code>(a . b)</code> stands for a cons cell whose CAR
is the object a and whose CDR is the object b. Dotted pair notation is more
general than list syntax because the CDR does not have to be a list. However, it
is more cumbersome in cases where list syntax would work. In dotted pair
notation, the list <code>(1 2 3)</code> is written as <code>(1 . (2 . (3 . nil)))</code>. For
nil-terminated lists, you can use either notation, but list notation is usually
clearer and more convenient. When printing a list, the dotted pair notation is
only used if the CDR of a cons cell is not a list.
</p>
</div>
</div>
<div id="outline-container-orgb68d8ad" class="outline-3">
<h3 id="orgb68d8ad"><span class="todo TODO">TODO</span> Example: Shortest Path</h3>
<div class="outline-text-3" id="text-orgb68d8ad">
<p>
Following code contains a program for finding the shortest path through a
network.  The function <code>shortest-path</code> takes a start node, a destination node,
and a network, and returns the shortest path, if there is one.
</p>


<p>
In this example, nodes are represented as symbols, and networks are represented
as assoc-lists with elements of the form
</p>

<div class="org-src-container">
<pre class="src src-lisp">(node . neighbors)
</pre>
</div>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf min '((a b c) (b c) (c d)))
</pre>
</div>

<p>
We can visualize it like this:
</p>


<figure id="orgdc99d00">
<img src="https://link.storjshare.io/raw/jvohwysyu55wt5daszrmhcbqh65a/blog/public/new/Oa3OgZT.png" alt="Oa3OgZT.png">

</figure>


<p>
Ewisshblanja2] is talking with me about [Lisp Programming Language.
</p>
</div>
</div>

<div id="outline-container-orgb36badf" class="outline-3">
<h3 id="orgb36badf">Garbage</h3>
<div class="outline-text-3" id="text-orgb36badf">
<p>
Lists can be slow for several reasons. They offer sequential instead of random
access, so retrieving a given element takes longer in a list than an array, for
the same reason that it takes longer to find something on a tape than on a disk.
Internally, conses tend to be represented as pointers, so traversing a list
means traversing a series of pointers, instead of simply incrementing an index,
as in an array. But these two costs can be small compared to the cost of
allocating and recycling cons cells.
</p>

<p>
Automatic memory management is one of Lisp's most valuable features.  The Lisp
system maintains a segment of memory called the heap. The system keeps track of
unused memory in the heap and doles it out as new objects are created. The
function cons, for example, returns a newly allocated cons.
</p>

<p>
Allocating memory from the heap is sometimes generically known as consing.  If
such memory were never freed, Lisp would run out of space for new objects and
have to shut down. So the system must periodically search through the heap,
looking for memory that is no longer needed. Memory that is no longer needed is
called garbage, and the scavenging operation is called garbage collection, or
GC.
</p>

<pre class="example" id="org3c4495b">
&gt; (setf 1st (list 'a &gt;b }c))
(A B C)
&gt; (setf 1st nil)
NIL
</pre>


<p>
Since we have no way of reaching this list, it might as well not exist.
Objects that we no longer have any way of reaching are garbage. The system
can safely reuse these three cons cells.
</p>

<p>
This way of managing memory is a great convenience to the programmer.
You never have to allocate or deallocate memory explicitly. And this means
that you never have to deal with the bugs that come from doing so. Memory
</p>


<p>
leaks and dangling pointers are simply impossible in Lisp.
</p>
</div>
</div>
</div>

<div id="outline-container-org2eb1407" class="outline-2">
<h2 id="org2eb1407">Data Structure</h2>
<div class="outline-text-2" id="text-org2eb1407">
<p>
The preceding discussed the list, Lisp's most versatile data structure.  This
chapter shows how to use Lisp's other data structures: arrays (including vectors
and strings), structures, and hash tables. They may not be as flexible as lists,
but they can make access faster, and take up less space.
</p>
</div>
<div id="outline-container-orgf02e031" class="outline-3">
<h3 id="orgf02e031">Arrays</h3>
<div class="outline-text-3" id="text-orgf02e031">
<p>
In Common Lisp, you can make an array by calling make-array with a list
of dimensions as the first argument. To make a 2x3 array we would say:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(make-array '(2 3))
</pre>
</div>
<p>
The <code>n</code> before the A tells how many dimensions the array have. You can also pass
a tag <code>initial-element</code> to set its value:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(make-array '(2 3) <span style="font-weight: bold;">:initial-element</span> 2)
</pre>
</div>

<p>
We can access both vectors and arrays using <code>aref</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(aref (make-array '(2 3) <span style="font-weight: bold;">:initial-element</span> 2) 0 0)
</pre>
</div>

<p>
However, in the cause of vectors there is a fastere function which is <code>svref</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(svref (vector 'a 'b 'c) 2)
</pre>
</div>
</div>
</div>
<div id="outline-container-org73618c4" class="outline-3">
<h3 id="org73618c4"><span class="todo TODO">TODO</span> Structures</h3>
</div>
</div>
<div id="outline-container-org755beea" class="outline-2">
<h2 id="org755beea">Functions</h2>
<div class="outline-text-2" id="text-org755beea">
<p>
Understanding functions is one of the keys to understanding Lisp. Conceptually,
functions are at the core of Lisp. Practically, they are one of the most useful
tools at your disposal
</p>


<p>
The predicate f boundp tells whether there is a function with a given symbol as
its name. If a symbol is the name of a function, symbol-function will return it:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(fboundp '+)
</pre>
</div>

<p>
By setting the symbol-function of some name to a function,
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf (symbol-function 'add2) #'(<span style="font-weight: bold;">lambda</span> (x) (+ x 2)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(add2 3)
</pre>
</div>
</div>

<div id="outline-container-org6ab589c" class="outline-3">
<h3 id="org6ab589c">Tags</h3>
<div class="outline-text-3" id="text-org6ab589c">
<p>
We've already seen four functions for retrieving elements of sequences:
nth for lists, aref and svref for vectors, and char for strings. Common
Lisp also provides a function <code>elt</code> that works for sequences of any kind:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(elt '(a b c) 1)
</pre>
</div>

<p>
Many sequence functions take one or more keyword arguments from the
standard set listed in this table:
</p>


<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Paramater</td>
<td class="org-left">Purpose</td>
<td class="org-left"><code>DEAFULT</code></td>
</tr>

<tr>
<td class="org-left"><code>:key</code></td>
<td class="org-left">a function to apply to all elements</td>
<td class="org-left"><code>identity</code></td>
</tr>

<tr>
<td class="org-left"><code>:test</code></td>
<td class="org-left">the test function for comparison</td>
<td class="org-left"><code>eql</code></td>
</tr>

<tr>
<td class="org-left"><code>:from-end</code></td>
<td class="org-left">if true, work backwards</td>
<td class="org-left"><code>nil</code></td>
</tr>

<tr>
<td class="org-left"><code>:start</code></td>
<td class="org-left">position at which start</td>
<td class="org-left"><code>0</code></td>
</tr>

<tr>
<td class="org-left"><code>:end</code></td>
<td class="org-left">position, if any, at which to stop</td>
<td class="org-left"><code>nil</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org8372260" class="outline-2">
<h2 id="org8372260">Functional Programming</h2>
<div class="outline-text-2" id="text-org8372260">
<p>
Functional programming means writing programs that work by returning values,
instead of by modifying things. It is the dominant paradigm in Lisp.  Most
built-in Lisp functions are meant to be called for the values they return, not
for side-effects.
</p>

<p>
The function remove, for example, takes an object and a list and returns
a new list containing everything but that object:
</p>

<p>
Why not just say that remove removes an object from a list? Because that's not
what it does. The original list is untouched afterwards:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf 1st ' (c a r a t ) )
(remove 'a 1st)
</pre>
</div>

<p>
Why not just say that remove removes an object from a list? Because that's
not what it does. The original list is untouched afterwards.
</p>
<div class="org-src-container">
<pre class="src src-lisp">1st
</pre>
</div>

<p>
So what if you really do want to remove something from a list? In Lisp you
generally do such things by passing the list as an argument to some function,
and using setf with the return value. To remove all the as from a list x, we
say:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf x (remove 'a x))
</pre>
</div>

<p>
Functional programming means, essentially, avoiding setf and things
like it. At first sight it may be difficult to imagine how this is even possible,
let alone desirable. How can one build programs just by returning values?
</p>

<p>
It would be inconvenient to do without side-effects entirely. However, as
you read further, you may be surprised to discover how few you really need.
And the more side-effects you do without, the better off you'll be.
</p>



<p>
One of the most important advantages of functional programming is that it allows
interactive testing. In purely functional code, you can test each function as
you write it. If it returns the values you expect, you can be confident that it
is correct. The added confidence, in the aggregate, makes a huge difference. You
have instant turnaround when you make changes anywhere in a program. And this
instant turnaround enables a whole new style of programming, much as the
telephone, as compared to letters, enabled a new style of communication.
</p>
</div>
</div>
<div id="outline-container-orgfe3e18d" class="outline-2">
<h2 id="orgfe3e18d">Some Other Resources</h2>
<div class="outline-text-2" id="text-orgfe3e18d">
<ul class="org-ul">
<li><a href="https://www.reddit.com/r/lisp/comments/tna6zo/moving_from_the_beam_to_common_lisp_what_are_my/i21hjef/">Concurrncy</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgc7b3ce2" class="outline-2">
<h2 id="orgc7b3ce2"><span class="todo TODO">TODO</span> Ray-Tracing</h2>
</div>
<div id="outline-container-org40f4592" class="outline-2">
<h2 id="org40f4592">Misc: <code>eqal?</code></h2>
<div class="outline-text-2" id="text-org40f4592">
<ul class="org-ul">
<li><p>
<code>(eq x y)</code> is true if and only if x and y are the same identical object.
</p>
<pre class="example" id="org86db219">
(eq 'a 'b) is false.
(eq 'a 'a) is true.
(eq 3 3) might be true or false, depending on the implementation.
(eq 3 3.0) is false.
(eq 3.0 3.0) might be true or false, depending on the implementation.
(eq #c(3 -4) #c(3 -4))
  might be true or false, depending on the implementation.
(eq #c(3 -4.0) #c(3 -4)) is false.
(eq (cons 'a 'b) (cons 'a 'c)) is false.
(eq (cons 'a 'b) (cons 'a 'b)) is false.
(eq '(a . b) '(a . b)) might be true or false.
(progn (setq x (cons 'a 'b)) (eq x x)) is true.
(progn (setq x '(a . b)) (eq x x)) is true.
(eq #\A #\A) might be true or false, depending on the implementation.
(eq "Foo" "Foo") might be true or false.
(eq "Foo" (copy-seq "Foo")) is false.
(eq "FOO" "foo") is false.

</pre></li>

<li><p>
The <code>eql</code> predicate is true if its arguments are <code>eq</code>, or if they are numbers
of the same type with the same value, or if they are character objects that
represent the same character.
</p>
<pre class="example" id="org4476915">
(eql 'a 'b) is false.
(eql 'a 'a) is true.
(eql 3 3) is true.
(eql 3 3.0) is false.
(eql 3.0 3.0) is true.
(eql #c(3 -4) #c(3 -4)) is true.
(eql #c(3 -4.0) #c(3 -4)) is false.
(eql (cons 'a 'b) (cons 'a 'c)) is false.
(eql (cons 'a 'b) (cons 'a 'b)) is false.
(eql '(a . b) '(a . b)) might be true or false.
(progn (setq x (cons 'a 'b)) (eql x x)) is true.
(progn (setq x '(a . b)) (eql x x)) is true.
(eql #\A #\A) is true.
(eql "Foo" "Foo") might be true or false.
(eql "Foo" (copy-seq "Foo")) is false.
(eql "FOO" "foo") is false.
</pre></li>

<li>The <code>equal</code> predicate is true if its arguments are structurally similar
(isomorphic) objects. A rough rule of thumb is that two objects are equal if
and only if their printed representations are the same.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr>
<a id="homeLink" style="text-decoration: none;" accesskey="h" href="/index.html">Navigate to home</a>
<script>
    var currentPage = window.location.href;

    var lastSlashIndex = currentPage.lastIndexOf('/');
    var currentPath = currentPage.substring(lastSlashIndex + 1);

    if (currentPath === "index.html" || currentPath === '') {
      var homeLink = document.getElementById("homeLink");
      homeLink.style.display = "none";
    }
</script>

<p> Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.0.50 (<a href="https://orgmode.org">Org</a> mode 9.6.6). Author: Salih Muhammed. Last build date: 2023-06-01 Thu 00:59.</p>
</div>
</div>
</div>
</body>
</html>